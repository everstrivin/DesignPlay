<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Deep Time Timeline Explorer</title>
    <style>
        :root {
            color-scheme: light;
            font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            --accent: #0ea5e9;
            --accent-dark: #0284c7;
            --surface: rgba(255, 255, 255, 0.88);
            --shadow: 0 25px 60px rgba(15, 23, 42, 0.18);
            --text-muted: #475569;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem 1.5rem;
            background: radial-gradient(circle at top, #f0f9ff, #dbeafe 45%, #c7d2fe 100%);
            color: #0f172a;
        }

        .app {
            width: min(1080px, 100%);
            background: var(--surface);
            border-radius: 28px;
            overflow: hidden;
            box-shadow: var(--shadow);
            backdrop-filter: blur(12px);
        }

        header {
            padding: 2.5rem 3rem 2rem;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.9), rgba(6, 182, 212, 0.9));
            color: white;
        }

        header h1 {
            margin: 0 0 0.75rem;
            font-size: clamp(2rem, 3vw, 2.6rem);
            letter-spacing: 0.02em;
        }

        header p {
            margin: 0;
            max-width: 720px;
            font-size: 1.05rem;
            line-height: 1.6;
        }

        .panel {
            padding: 2.5rem 3rem 2rem;
            background: rgba(248, 250, 252, 0.9);
        }

        .control-grid {
            display: grid;
            gap: 1.8rem;
        }

        .control-row {
            display: grid;
            gap: 0.5rem;
        }

        label {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        select,
        input[type="number"] {
            width: 100%;
            border-radius: 14px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            padding: 0.9rem 1rem;
            font-size: 1rem;
            transition: border 0.2s ease, box-shadow 0.2s ease;
            background: white;
        }

        select:focus,
        input[type="number"]:focus {
            outline: none;
            border-color: rgba(14, 165, 233, 0.7);
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2);
        }

        .control-row input[type="range"] {
            width: 100%;
            margin-top: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .date-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .date-field {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .field-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .date-field input[type="number"],
        .date-field select {
            padding: 0.6rem 0.5rem;
            font-size: 0.9rem;
        }

        .hint {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .controls-footer {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
        }

        button {
            border: none;
            border-radius: 999px;
            padding: 0.85rem 1.6rem;
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: white;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 15px 30px rgba(2, 132, 199, 0.25);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 20px 40px rgba(2, 132, 199, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .timeline-card {
            padding: 2.5rem 3rem 3rem;
            display: grid;
            gap: 1.5rem;
            background: white;
        }

        .timeline-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem 2rem;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        .timeline-meta strong {
            color: #0f172a;
        }

        .range-display {
            border-radius: 18px;
            padding: 1rem 1.25rem;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.08), rgba(59, 130, 246, 0.12));
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .slider-area {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .slider-area label {
            color: #0f172a;
        }

        .dual-timeline-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            margin-top: 1rem;
        }

        .range-slider-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .range-slider-label {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        .range-slider-wrapper {
            position: relative;
            height: 50px;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.15), rgba(37, 99, 235, 0.15));
            border-radius: 12px;
            padding: 0 12px;
        }

        .range-slider-track {
            position: absolute;
            top: 50%;
            left: 12px;
            right: 12px;
            height: 8px;
            transform: translateY(-50%);
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.3);
        }

        .range-slider-selected {
            position: absolute;
            top: 50%;
            height: 8px;
            transform: translateY(-50%);
            border-radius: 999px;
            background: linear-gradient(90deg, var(--accent), var(--accent-dark));
            cursor: grab;
        }

        .range-slider-selected:active {
            cursor: grabbing;
        }

        .range-handle {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(14, 165, 233, 0.3);
            border: 3px solid white;
            z-index: 10;
        }

        .range-handle:hover {
            transform: translate(-50%, -50%) scale(1.15);
        }

        .range-handle:active {
            transform: translate(-50%, -50%) scale(1.05);
        }

        /* Slider boundary control wrappers at ends of coarse slider */
        .slider-boundary-control {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
        }

        .slider-boundary-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(14, 165, 233, 0.3);
            border: 3px solid white;
            transition: transform 0.2s ease;
        }

        .slider-boundary-icon:hover {
            transform: scale(1.1);
        }

        .slider-boundary-icon span {
            font-size: 16px;
            color: white;
        }

        .range-controls {
            position: absolute;
            top: calc(100% + 8px);
            background: white;
            border-radius: 14px;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.25);
            padding: 1rem;
            min-width: 420px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease 0.15s, visibility 0s linear 0.35s;
            border: 1px solid rgba(148, 163, 184, 0.25);
        }
        
        /* Add invisible bridge to maintain hover state */
        .range-controls::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            height: 16px;
            background: transparent;
        }

        /* Keep popup visible with delay when hovering either icon or popup */
        .slider-boundary-control:hover .range-controls {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.2s ease, visibility 0s linear;
        }

        .range-controls:hover {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.2s ease, visibility 0s linear;
        }

        .range-controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        }

        .range-controls-header span {
            font-weight: 600;
            font-size: 0.95rem;
            color: #0f172a;
        }

        .apply-btn {
            padding: 0.4rem 0.9rem;
            font-size: 0.85rem;
            border-radius: 8px;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
            transition: transform 0.2s ease;
        }

        .apply-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(14, 165, 233, 0.4);
        }

        .apply-btn:active {
            transform: translateY(0);
        }

        /* Position start control popup to the right */
        #sliderStartControl .range-controls {
            left: 0;
        }

        /* Position end control popup to the left */
        #sliderEndControl .range-controls {
            right: 0;
            left: auto;
        }

        .range-slider-info {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 14px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.25), rgba(37, 99, 235, 0.25));
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 12px 20px rgba(14, 165, 233, 0.25);
            border: 3px solid white;
        }

        input[type="range"]::-moz-range-thumb {
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 12px 20px rgba(14, 165, 233, 0.25);
            border: 3px solid white;
        }

        .timeline {
            position: relative;
            border-radius: 22px;
            padding: 3.2rem 2.2rem 3.5rem;
            background: radial-gradient(circle at top, rgba(14, 165, 233, 0.12), rgba(59, 130, 246, 0.08)),
                linear-gradient(135deg, rgba(148, 163, 184, 0.2), rgba(148, 163, 184, 0.05));
            overflow: visible;
        }

        .timeline-inner {
            position: relative;
            margin: 0 2rem;
        }

        .timeline-track {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 10px;
            transform: translateY(-50%);
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.3), rgba(2, 132, 199, 0.6), rgba(14, 165, 233, 0.3));
            box-shadow: inset 0 0 12px rgba(14, 165, 233, 0.35);
        }

        .timeline-ticks {
            position: relative;
            min-height: 140px;
        }

        .tick {
            position: absolute;
            top: 0;
            transform: translateX(-50%);
            text-align: center;
            color: var(--text-muted);
            width: 120px;
        }

        .tick-line {
            display: block;
            margin: 0 auto 0.6rem;
            width: 2px;
            height: 32px;
            background: linear-gradient(180deg, rgba(14, 165, 233, 0.25), rgba(14, 165, 233, 0));
        }

        .tick-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #1e293b;
            text-shadow: 0 1px 2px rgba(148, 163, 184, 0.35);
            display: block;
            line-height: 1.3;
        }

        .pointer {
            position: absolute;
            top: 28%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.4rem;
            pointer-events: none;
        }

        .pointer::after {
            content: "";
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            box-shadow: 0 0 0 8px rgba(14, 165, 233, 0.18);
        }

        .pointer-label {
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.92), rgba(2, 132, 199, 0.92));
            color: white;
            font-size: 0.78rem;
            letter-spacing: 0.03em;
            text-transform: uppercase;
            box-shadow: 0 12px 24px rgba(14, 165, 233, 0.35);
        }

        .current-time {
            border-radius: 20px;
            padding: 1.5rem 1.75rem;
            background: linear-gradient(135deg, rgba(240, 249, 255, 0.7), rgba(224, 242, 254, 0.85));
            box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.25);
            display: grid;
            gap: 0.65rem;
            font-size: 1rem;
        }

        .current-time h3 {
            margin: 0;
            font-size: 1.05rem;
            color: #0f172a;
            letter-spacing: 0.01em;
        }

        .current-time span {
            color: var(--text-muted);
        }

        .footnote {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.6;
        }

        @media (min-width: 720px) {
            .control-grid {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }

            .control-row:nth-child(2),
            .control-row:nth-child(3) {
                grid-column: span 1;
            }

            .controls-footer {
                grid-column: span 3;
                justify-content: space-between;
            }
        }

        @media (max-width: 640px) {
            header,
            .panel,
            .timeline-card {
                padding: 2rem 1.5rem;
            }

            .tick {
                width: 96px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header>
            <h1>Deep Time Timeline Explorer</h1>
            <p>
                Navigate the grand sweep of time from Earth's formation (~4.54 billion BCE) to an equally distant
                future. The exact midpoint is fixed at 12:00:01&nbsp;AM on January&nbsp;1, 0001.
            </p>
        </header>
        <section class="panel">
            <div class="control-grid">
                <div class="controls-footer">
                    <div class="footnote">
                        Bounds: &minus;4.54 billion years to +4.54 billion years relative to the center point.
                    </div>
                </div>
            </div>
        </section>
        <section class="timeline-card">
            <div class="timeline-meta">
                <div><strong>Earliest point:</strong> ~4.54&nbsp;billion&nbsp;BCE</div>
                <div><strong>Midpoint:</strong> 12:00:01&nbsp;AM · January&nbsp;1, 0001</div>
                <div><strong>Most distant future:</strong> ~4.54&nbsp;billion&nbsp;CE</div>
            </div>
            <div class="range-display" id="rangeDisplay"></div>
            <div class="dual-timeline-container">
                <!-- Top Timeline: Fine Range Selector -->
                <div class="range-slider-container">
                    <div class="range-slider-label">Top Timeline (Fine Level)</div>
                    <div class="range-slider-wrapper" id="topSliderWrapper">
                        <div class="range-slider-track"></div>
                        <div class="range-slider-selected" id="topSelected"></div>
                        <div class="range-handle" id="topStartHandle"></div>
                        <div class="range-handle" id="topEndHandle"></div>
                        
                        <!-- Fine Granularity Control at left end of fine slider track -->
                        <div class="slider-boundary-control" id="topSliderStartControl" style="left: 0;">
                            <div class="slider-boundary-icon">
                                <span>⚙</span>
                            </div>
                            <div class="range-controls" id="topStartControls">
                                <div class="range-controls-header">
                                    <span>Fine Granularity</span>
                                    <button class="apply-btn" id="applyTopGranularityBtn">Apply</button>
                                </div>
                                <div class="date-inputs">
                                    <div class="date-field" style="grid-column: 1 / -1;">
                                        <label for="fineGranularitySelect" class="field-label">Granularity Level</label>
                                        <select id="fineGranularitySelect" style="width: 100%;">
                                            <option value="Eon">Eon (500M years)</option>
                                            <option value="Epoch">Epoch (50M years)</option>
                                            <option value="Age">Age (5M years)</option>
                                            <option value="Millennium">Millennium (1K years)</option>
                                            <option value="Century">Century (100 years)</option>
                                            <option value="Decade">Decade (10 years)</option>
                                            <option value="Year">Year</option>
                                            <option value="Month">Month</option>
                                            <option value="Week">Week</option>
                                            <option value="Day">Day</option>
                                            <option value="Hour">Hour</option>
                                            <option value="Minute">Minute</option>
                                        </select>
                                    </div>
                                    <div class="date-field" style="grid-column: 1 / -1;">
                                        <p style="font-size: 0.85rem; color: #475569; margin: 0.5rem 0 0 0; line-height: 1.4;">
                                            This controls the granularity of the fine slider and automatically adjusts its span to maintain smooth navigation (at least 10 units).
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="range-slider-info" id="topInfo"></div>
                </div>

                <!-- Bottom Timeline: Coarse Range Selector -->
                <div class="range-slider-container">
                    <div class="range-slider-label">Bottom Timeline (Coarse Level)</div>
                    <div class="range-slider-wrapper" id="bottomSliderWrapper">
                        <div class="range-slider-track"></div>
                        <div class="range-slider-selected" id="bottomSelected"></div>
                        <div class="range-handle" id="bottomStartHandle"></div>
                        <div class="range-handle" id="bottomEndHandle"></div>
                        
                        <!-- View Start Control at left end of coarse slider track -->
                        <div class="slider-boundary-control" id="sliderStartControl" style="left: 0;">
                            <div class="slider-boundary-icon">
                                <span>⚙</span>
                            </div>
                            <div class="range-controls" id="startControls">
                                <div class="range-controls-header">
                                    <span>View Start</span>
                                    <button class="apply-btn" id="applyStartBtn">Apply</button>
                                </div>
                                <div class="date-inputs">
                                    <div class="date-field">
                                        <label for="startEra" class="field-label">Era</label>
                                        <select id="startEra">
                                            <option value="-1">BCE</option>
                                            <option value="1">CE</option>
                                        </select>
                                    </div>
                                    <div class="date-field">
                                        <label for="startYearComp" class="field-label">Year</label>
                                        <input type="number" id="startYearComp" value="1000001" min="1" max="4540000000" />
                                    </div>
                                    <div class="date-field">
                                        <label for="startMonth" class="field-label">Month</label>
                                        <input type="number" id="startMonth" value="1" min="1" max="12" />
                                    </div>
                                    <div class="date-field">
                                        <label for="startDay" class="field-label">Day</label>
                                        <input type="number" id="startDay" value="1" min="1" max="31" />
                                    </div>
                                    <div class="date-field">
                                        <label for="startHour" class="field-label">Hour</label>
                                        <input type="number" id="startHour" value="0" min="0" max="23" />
                                    </div>
                                    <div class="date-field">
                                        <label for="startMinute" class="field-label">Minute</label>
                                        <input type="number" id="startMinute" value="0" min="0" max="59" />
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- View End Control at right end of coarse slider track -->
                        <div class="slider-boundary-control" id="sliderEndControl" style="right: 0;">
                            <div class="slider-boundary-icon">
                                <span>⚙</span>
                            </div>
                            <div class="range-controls" id="endControls">
                                <div class="range-controls-header">
                                    <span>View End</span>
                                    <button class="apply-btn" id="applyEndBtn">Apply</button>
                                </div>
                                <div class="date-inputs">
                                    <div class="date-field">
                                        <label for="endEra" class="field-label">Era</label>
                                        <select id="endEra">
                                            <option value="-1">BCE</option>
                                            <option value="1" selected>CE</option>
                                        </select>
                                    </div>
                                    <div class="date-field">
                                        <label for="endYearComp" class="field-label">Year</label>
                                        <input type="number" id="endYearComp" value="1000001" min="1" max="4540000000" />
                                    </div>
                                    <div class="date-field">
                                        <label for="endMonth" class="field-label">Month</label>
                                        <input type="number" id="endMonth" value="1" min="1" max="12" />
                                    </div>
                                    <div class="date-field">
                                        <label for="endDay" class="field-label">Day</label>
                                        <input type="number" id="endDay" value="1" min="1" max="31" />
                                    </div>
                                    <div class="date-field">
                                        <label for="endHour" class="field-label">Hour</label>
                                        <input type="number" id="endHour" value="0" min="0" max="23" />
                                    </div>
                                    <div class="date-field">
                                        <label for="endMinute" class="field-label">Minute</label>
                                        <input type="number" id="endMinute" value="0" min="0" max="59" />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="range-slider-info" id="bottomInfo"></div>
                </div>
            </div>
            <div class="timeline">
                <div class="timeline-inner">
                    <div class="timeline-track"></div>
                    <div class="timeline-ticks" id="timelineTicks"></div>
                    <div class="pointer" id="timelinePointer">
                        <span class="pointer-label" id="pointerLabel">Center</span>
                    </div>
                </div>
            </div>
            <div class="current-time" id="currentTime"></div>
        </section>
    </div>

    <script>
        const MINUTES_PER_YEAR = 525600;
        const MINUTES_PER_MONTH = MINUTES_PER_YEAR / 12;
        const MINUTES_PER_WEEK = 10080;
        const MINUTES_PER_DAY = 1440;
        const MINUTES_PER_HOUR = 60;

        const EARTH_AGE_YEARS = 4_540_000_000;
        const HALF_SPAN_MINUTES = EARTH_AGE_YEARS * MINUTES_PER_YEAR;
        const TIMELINE_MIN = -HALF_SPAN_MINUTES;
        const TIMELINE_MAX = HALF_SPAN_MINUTES;

        const GRANULARITY_TO_MINUTES = {
            Eon: MINUTES_PER_YEAR * 500_000_000,
            Epoch: MINUTES_PER_YEAR * 50_000_000,
            Age: MINUTES_PER_YEAR * 5_000_000,
            Millennium: MINUTES_PER_YEAR * 1_000,
            Century: MINUTES_PER_YEAR * 100,
            Decade: MINUTES_PER_YEAR * 10,
            Year: MINUTES_PER_YEAR,
            Month: MINUTES_PER_MONTH,
            Week: MINUTES_PER_WEEK,
            Day: MINUTES_PER_DAY,
            Hour: MINUTES_PER_HOUR,
            Minute: 1
        };

        const UNIT_LABELS = {
            Eon: { singular: "eon", plural: "eons" },
            Epoch: { singular: "epoch", plural: "epochs" },
            Age: { singular: "age", plural: "ages" },
            Millennium: { singular: "millennium", plural: "millennia" },
            Century: { singular: "century", plural: "centuries" },
            Decade: { singular: "decade", plural: "decades" },
            Year: { singular: "year", plural: "years" },
            Month: { singular: "month", plural: "months" },
            Week: { singular: "week", plural: "weeks" },
            Day: { singular: "day", plural: "days" },
            Hour: { singular: "hour", plural: "hours" },
            Minute: { singular: "minute", plural: "minutes" }
        };

        const compactFormatter = new Intl.NumberFormat("en-US", {
            notation: "compact",
            maximumFractionDigits: 1
        });
        const numberFormatter = new Intl.NumberFormat("en-US");
        
        // Custom formatter for years: no commas for 4-digit years (1000-9999)
        function formatYear(year) {
            const absYear = Math.abs(year);
            if (absYear >= 1000 && absYear <= 9999) {
                return absYear.toString();
            }
            return numberFormatter.format(absYear);
        }
        
        const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        
        // Start date components
        const startEra = document.getElementById("startEra");
        const startYearComp = document.getElementById("startYearComp");
        const startMonth = document.getElementById("startMonth");
        const startDay = document.getElementById("startDay");
        const startHour = document.getElementById("startHour");
        const startMinute = document.getElementById("startMinute");
        
        // End date components
        const endEra = document.getElementById("endEra");
        const endYearComp = document.getElementById("endYearComp");
        const endMonth = document.getElementById("endMonth");
        const endDay = document.getElementById("endDay");
        const endHour = document.getElementById("endHour");
        const endMinute = document.getElementById("endMinute");
        
        const rangeDisplay = document.getElementById("rangeDisplay");
        const timelineTicks = document.getElementById("timelineTicks");
        const pointer = document.getElementById("timelinePointer");
        const pointerLabel = document.getElementById("pointerLabel");
        const currentTime = document.getElementById("currentTime");

        // Bottom timeline elements
        const bottomSliderWrapper = document.getElementById("bottomSliderWrapper");
        const bottomSelected = document.getElementById("bottomSelected");
        const bottomStartHandle = document.getElementById("bottomStartHandle");
        const bottomEndHandle = document.getElementById("bottomEndHandle");
        const bottomInfo = document.getElementById("bottomInfo");
        const applyStartBtn = document.getElementById("applyStartBtn");
        const applyEndBtn = document.getElementById("applyEndBtn");

        // Top timeline elements
        const topSliderWrapper = document.getElementById("topSliderWrapper");
        const topSelected = document.getElementById("topSelected");
        const topStartHandle = document.getElementById("topStartHandle");
        const topEndHandle = document.getElementById("topEndHandle");
        const topInfo = document.getElementById("topInfo");

        // Timeline state
        // Bottom timeline: user's coarse range selection (boundaries are TIMELINE_MIN to TIMELINE_MAX)
        let bottomStartMinutes = -1_000_000 * MINUTES_PER_YEAR;
        let bottomEndMinutes = 1_000_000 * MINUTES_PER_YEAR;
        // Top timeline: user's fine range selection (boundaries are bottomStart to bottomEnd)
        let topStartMinutes = -500_000 * MINUTES_PER_YEAR;
        let topEndMinutes = 500_000 * MINUTES_PER_YEAR;

        let viewStartMinutes = -1_000_000 * MINUTES_PER_YEAR;
        let viewEndMinutes = 1_000_000 * MINUTES_PER_YEAR;
        let currentViewMinutes = 0; // Current position shown on the timeline
        
        // Track manual fine granularity override (null means auto-calculate)
        let manualFineGranularity = null;

        function getGranularityIndex(granularity) {
            const granularities = Object.keys(GRANULARITY_TO_MINUTES);
            return granularities.indexOf(granularity);
        }

        function getGranularityTwoLevelsLess(granularity) {
            const granularities = Object.keys(GRANULARITY_TO_MINUTES);
            const currentIndex = getGranularityIndex(granularity);
            const targetIndex = Math.min(currentIndex + 2, granularities.length - 1);
            return granularities[targetIndex];
        }
        
        // Get the current fine granularity (manual override or auto-calculated)
        function getCurrentFineGranularity() {
            if (manualFineGranularity) {
                return manualFineGranularity;
            }
            const bottomSpan = bottomEndMinutes - bottomStartMinutes;
            return calculateFineGranularity(bottomSpan);
        }

        // Calculate appropriate fine granularity based on the span of the bottom slider's range
        // The goal is to find a granularity such that the fine slider takes up approximately
        // 1/4 of the track width while providing smooth navigation
        function calculateFineGranularity(spanMinutes) {
            const granularities = Object.keys(GRANULARITY_TO_MINUTES);
            const granularityValues = Object.values(GRANULARITY_TO_MINUTES);
            
            // Target: fine slider should span about 1/4 of the bottom slider's range
            // This means we want a granularity where 10-40 units fit in 1/4 of the span
            const targetSpan = spanMinutes / 4;
            
            // Find the COARSEST granularity where we have at least 10 units in the target span
            // Start from coarsest and work toward finer
            for (let i = 0; i < granularities.length; i++) {
                const unitMinutes = granularityValues[i];
                const numUnitsInQuarter = targetSpan / unitMinutes;
                
                // We want at least 10 units to provide smooth sliding
                if (numUnitsInQuarter >= 10) {
                    return granularities[i];
                }
            }
            
            // If even the finest granularity doesn't give us 10 units, use it anyway
            return granularities[granularities.length - 1];
        }

        function initializeTimelines() {
            // Initialize view boundaries from date inputs (will be updated by updateDateInputs)
            // Bottom timeline range should start within these boundaries
            const midpoint = (viewStartMinutes + viewEndMinutes) / 2;
            const quarterSpan = (viewEndMinutes - viewStartMinutes) / 4;
            
            // Set bottom timeline to middle half of the view range
            bottomStartMinutes = midpoint - quarterSpan;
            bottomEndMinutes = midpoint + quarterSpan;
            
            // Set top timeline to take up 1/4 of bottom range width
            const topMidpoint = (bottomStartMinutes + bottomEndMinutes) / 2;
            const topHalfSpan = (bottomEndMinutes - bottomStartMinutes) / 8; // 1/8 to get 1/4 total
            topStartMinutes = topMidpoint - topHalfSpan;
            topEndMinutes = topMidpoint + topHalfSpan;
            
            // Set view to show the top timeline's range
            currentViewMinutes = topMidpoint;
        }

        function clampMinutes(value) {
            return Math.min(Math.max(value, TIMELINE_MIN), TIMELINE_MAX);
        }

        // Convert date components to minutes from center
        function dateComponentsToMinutes(era, year, month, day, hour, minute) {
            const eraSign = parseInt(era);
            const y = parseInt(year) || 1;
            const m = parseInt(month) || 1;
            const d = parseInt(day) || 1;
            const h = parseInt(hour) || 0;
            const min = parseInt(minute) || 0;
            
            // Calculate total minutes from year 1 CE (which is at 0 minutes)
            let totalMinutes = 0;
            
            if (eraSign === 1) {
                // CE: Year 1 CE starts at 0, Year 2 CE starts at MINUTES_PER_YEAR, etc.
                totalMinutes = (y - 1) * MINUTES_PER_YEAR;
                totalMinutes += (m - 1) * MINUTES_PER_MONTH;
                totalMinutes += (d - 1) * MINUTES_PER_DAY;
                totalMinutes += h * MINUTES_PER_HOUR;
                totalMinutes += min;
            } else {
                // BCE: Year 1 BCE starts at -MINUTES_PER_YEAR, Year 2 BCE starts at -2*MINUTES_PER_YEAR, etc.
                // Within each year, months/days/hours/minutes add forward (Jan=left, Dec=right)
                totalMinutes = -(y * MINUTES_PER_YEAR);
                totalMinutes += (m - 1) * MINUTES_PER_MONTH;
                totalMinutes += (d - 1) * MINUTES_PER_DAY;
                totalMinutes += h * MINUTES_PER_HOUR;
                totalMinutes += min;
            }
            
            return totalMinutes;
        }

        // Convert minutes from center to date components
        function minutesToDateComponents(minutes) {
            if (minutes >= 0) {
                // CE: straightforward calculation
                let remaining = minutes;
                const years = Math.floor(remaining / MINUTES_PER_YEAR);
                remaining -= years * MINUTES_PER_YEAR;
                
                const months = Math.floor(remaining / MINUTES_PER_MONTH);
                remaining -= months * MINUTES_PER_MONTH;
                
                const days = Math.floor(remaining / MINUTES_PER_DAY);
                remaining -= days * MINUTES_PER_DAY;
                
                const hours = Math.floor(remaining / MINUTES_PER_HOUR);
                remaining -= hours * MINUTES_PER_HOUR;
                
                const mins = Math.floor(remaining);
                
                return {
                    era: 1,
                    year: years + 1,
                    month: months + 1,
                    day: days + 1,
                    hour: hours,
                    minute: mins
                };
            } else {
                // BCE: Year N BCE spans from -(N*MINUTES_PER_YEAR) to -((N-1)*MINUTES_PER_YEAR)
                const absMinutes = Math.abs(minutes);
                const years = Math.ceil(absMinutes / MINUTES_PER_YEAR);
                
                // Calculate the start of this year (most negative point)
                const yearStart = -(years * MINUTES_PER_YEAR);
                
                // Calculate offset from year start (positive for sub-year components)
                const offsetFromYearStart = minutes - yearStart;
                
                let remaining = offsetFromYearStart;
                const months = Math.floor(remaining / MINUTES_PER_MONTH);
                remaining -= months * MINUTES_PER_MONTH;
                
                const days = Math.floor(remaining / MINUTES_PER_DAY);
                remaining -= days * MINUTES_PER_DAY;
                
                const hours = Math.floor(remaining / MINUTES_PER_HOUR);
                remaining -= hours * MINUTES_PER_HOUR;
                
                const mins = Math.floor(remaining);
                
                return {
                    era: -1,
                    year: years,
                    month: months + 1,
                    day: days + 1,
                    hour: hours,
                    minute: mins
                };
            }
        }

        // Update the date component inputs based on current viewStartMinutes and viewEndMinutes
        function updateDateInputs() {
            const startComponents = minutesToDateComponents(viewStartMinutes);
            startEra.value = startComponents.era;
            startYearComp.value = startComponents.year;
            startMonth.value = startComponents.month;
            startDay.value = startComponents.day;
            startHour.value = startComponents.hour;
            startMinute.value = startComponents.minute;
            
            const endComponents = minutesToDateComponents(viewEndMinutes);
            endEra.value = endComponents.era;
            endYearComp.value = endComponents.year;
            endMonth.value = endComponents.month;
            endDay.value = endComponents.day;
            endHour.value = endComponents.hour;
            endMinute.value = endComponents.minute;
        }

        function updateViewRange() {
            // Get start date components
            let startMinutes = dateComponentsToMinutes(
                startEra.value,
                startYearComp.value,
                startMonth.value,
                startDay.value,
                startHour.value,
                startMinute.value
            );
            
            // Get end date components
            let endMinutes = dateComponentsToMinutes(
                endEra.value,
                endYearComp.value,
                endMonth.value,
                endDay.value,
                endHour.value,
                endMinute.value
            );
            
            startMinutes = clampMinutes(startMinutes);
            endMinutes = clampMinutes(endMinutes);

            if (startMinutes === endMinutes) {
                // Use a reasonable default minimum span (1 day)
                const minimumSpan = 1440; // 1 day in minutes
                if (endMinutes >= TIMELINE_MAX) {
                    startMinutes = Math.max(TIMELINE_MIN, endMinutes - minimumSpan);
                }
                endMinutes = Math.min(startMinutes + minimumSpan, TIMELINE_MAX);
            }

            if (startMinutes > endMinutes) {
                [startMinutes, endMinutes] = [endMinutes, startMinutes];
            }

            viewStartMinutes = startMinutes;
            viewEndMinutes = endMinutes;

            updateDateInputs();

            // Date inputs define the boundaries for the bottom slider
            // Initialize bottom slider to a reasonable position within these boundaries
            const viewSpan = viewEndMinutes - viewStartMinutes;
            const midpoint = (viewStartMinutes + viewEndMinutes) / 2;
            
            // Set bottom slider range to middle portion of view boundaries
            // Try to keep existing bottom range if it fits, otherwise reinitialize
            if (bottomStartMinutes < viewStartMinutes || bottomEndMinutes > viewEndMinutes) {
                // Bottom range is outside new boundaries, reinitialize
                const quarterSpan = viewSpan / 4;
                bottomStartMinutes = midpoint - quarterSpan;
                bottomEndMinutes = midpoint + quarterSpan;
            }
            
            // Ensure bottom timeline has a reasonable minimum span (1 day)
            const minBottomSpan = 1440; // 1 day in minutes
            if (bottomEndMinutes - bottomStartMinutes < minBottomSpan) {
                bottomEndMinutes = Math.min(viewEndMinutes, bottomStartMinutes + minBottomSpan);
                if (bottomEndMinutes - bottomStartMinutes < minBottomSpan) {
                    bottomStartMinutes = Math.max(viewStartMinutes, bottomEndMinutes - minBottomSpan);
                }
            }
            
            // Update top timeline to be centered within bottom range
            const bottomSpan = bottomEndMinutes - bottomStartMinutes;
            const fineGranularity = getCurrentFineGranularity();
            const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
            
            // Try to keep existing top range if it fits
            if (topStartMinutes < bottomStartMinutes || topEndMinutes > bottomEndMinutes) {
                // Top range is outside new bottom boundaries, reinitialize
                const bottomMidpoint = (bottomStartMinutes + bottomEndMinutes) / 2;
                // Target: 1/4 of bottom span, but at least 10 units of the fine granularity
                const targetTopSpan = Math.max(bottomSpan / 4, minTopSpan * 10);
                const topHalfSpan = targetTopSpan / 2;
                topStartMinutes = bottomMidpoint - topHalfSpan;
                topEndMinutes = bottomMidpoint + topHalfSpan;
            }
            
            // Ensure top timeline has minimum span (at least 10 granularity units)
            const minAllowedTopSpan = minTopSpan * 10;
            if (topEndMinutes - topStartMinutes < minAllowedTopSpan) {
                const currentMidpoint = (topStartMinutes + topEndMinutes) / 2;
                const halfSpan = minAllowedTopSpan / 2;
                topStartMinutes = Math.max(bottomStartMinutes, currentMidpoint - halfSpan);
                topEndMinutes = Math.min(bottomEndMinutes, currentMidpoint + halfSpan);
                // Adjust if we hit boundaries
                if (topEndMinutes - topStartMinutes < minAllowedTopSpan) {
                    topEndMinutes = Math.min(bottomEndMinutes, topStartMinutes + minAllowedTopSpan);
                    if (topEndMinutes - topStartMinutes < minAllowedTopSpan) {
                        topStartMinutes = Math.max(bottomStartMinutes, topEndMinutes - minAllowedTopSpan);
                    }
                }
            }
            
            updateRangeSliders();
            // Update the main view display to show the top timeline's range
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        function refreshRangeDisplay() {
            // Display the top timeline's current range, not the view boundaries
            const startLabel = formatYearLabel(topStartMinutes);
            const endLabel = formatYearLabel(topEndMinutes);
            const spanMinutes = topEndMinutes - topStartMinutes;
            let spanLabel;
            if (spanMinutes >= MINUTES_PER_YEAR) {
                spanLabel = `${numberFormatter.format(Math.round(spanMinutes / MINUTES_PER_YEAR))} years`;
            } else if (spanMinutes >= MINUTES_PER_MONTH) {
                spanLabel = `${numberFormatter.format(Math.round(spanMinutes / MINUTES_PER_MONTH))} months`;
            } else if (spanMinutes >= MINUTES_PER_DAY) {
                spanLabel = `${numberFormatter.format(Math.round(spanMinutes / MINUTES_PER_DAY))} days`;
            } else if (spanMinutes >= MINUTES_PER_HOUR) {
                spanLabel = `${numberFormatter.format(Math.round(spanMinutes / MINUTES_PER_HOUR))} hours`;
            } else {
                spanLabel = `${numberFormatter.format(Math.max(1, Math.round(spanMinutes)))} minutes`;
            }

            rangeDisplay.innerHTML = `Viewing from <strong>${startLabel}</strong> to <strong>${endLabel}</strong><br />`
                + `Window width: <strong>${spanLabel}</strong>`;
        }

        function rebuildTicks() {
            timelineTicks.innerHTML = "";
            const segments = 10;
            // Use top timeline's range for the ticks, not the view boundaries
            const rangeMinutes = topEndMinutes - topStartMinutes;

            for (let i = 0; i <= segments; i++) {
                const tick = document.createElement("div");
                tick.className = "tick";
                const percent = (i / segments) * 100;
                tick.style.left = `${percent}%`;

                const tickLine = document.createElement("span");
                tickLine.className = "tick-line";
                tick.appendChild(tickLine);

                const tickMinutes = topStartMinutes + rangeMinutes * (i / segments);
                const tickLabel = document.createElement("span");
                tickLabel.className = "tick-label";
                tickLabel.textContent = formatTickLabel(tickMinutes);
                tickLabel.title = formatDetailedTime(tickMinutes);
                tick.appendChild(tickLabel);

                timelineTicks.appendChild(tick);
            }
        }

        function formatSliderLabel(minutes, granularity) {
            if (Math.abs(minutes) < 0.5) {
                return "Center";
            }
            
            const components = minutesToDateComponents(minutes);
            const era = components.era === 1 ? "CE" : "BCE";
            const monthIndex = Math.min(Math.max(components.month - 1, 0), 11);
            
            // Format at the same granularity level as selected
            if (granularity === "Eon") {
                // Show in billions of years for Eon scale
                const eonYears = Math.round(components.year / 1_000_000_000);
                return `${compactFormatter.format(eonYears)} B yrs ${era}`;
            } else if (granularity === "Epoch") {
                // Show in millions of years for Epoch scale
                const epochYears = Math.round(components.year / 1_000_000);
                return `${compactFormatter.format(epochYears)} M yrs ${era}`;
            } else if (granularity === "Age") {
                // Show in thousands of years for Age scale
                const ageYears = Math.round(components.year / 1000);
                return `${compactFormatter.format(ageYears)}K yrs ${era}`;
            } else if (granularity === "Millennium") {
                // Show specific year for Millennium
                return `Year ${compactFormatter.format(components.year)} ${era}`;
            } else if (granularity === "Century") {
                // Show specific year for Century
                return `Year ${compactFormatter.format(components.year)} ${era}`;
            } else if (granularity === "Decade") {
                // Show specific year for Decade
                return `Year ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Year") {
                // Show specific year
                return `Year ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Month") {
                // Show Month and Year
                return `${MONTH_NAMES[monthIndex]} ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Week") {
                // Show Week (calculate from day of year using components)
                // components.month and components.day already account for BCE calendar order
                const dayOfYear = (components.month - 1) * 30 + (components.day - 1);
                const weekNum = Math.floor(dayOfYear / 7) + 1;
                return `Week ${weekNum}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Day") {
                // Show Month, Day, and Year
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Hour") {
                // Show Day and Time with Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${pad(components.hour)}:00 ${era}`;
            } else if (granularity === "Minute") {
                // Show Time with minutes and Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${pad(components.hour)}:${pad(components.minute)} ${era}`;
            }
            
            // Fallback
            return formatYearLabel(minutes);
        }

        function updatePointerAndDetails() {
            // Position pointer at the center of the current view (top timeline)
            const percent = 50; // Always show at center
            pointer.style.left = `${percent}%`;

            // Use current fine granularity (manual or auto-calculated)
            const fineGranularity = getCurrentFineGranularity();
            
            // Use the midpoint of the top timeline as the current view position
            currentViewMinutes = (topStartMinutes + topEndMinutes) / 2;
            
            // Format the pointer label with fine granularity
            const unitsLabel = formatSliderLabel(currentViewMinutes, fineGranularity);

            pointerLabel.textContent = unitsLabel;

            currentTime.innerHTML = `
                <h3>Selected moment</h3>
                <span>${formatDetailedTime(currentViewMinutes, fineGranularity)}</span>
                <span>${formatDifference(currentViewMinutes, fineGranularity)}</span>
            `;
        }

        function formatYearLabel(minutes) {
            if (minutes === 0) {
                return "Year 1 CE";
            }
            
            const components = minutesToDateComponents(minutes);
            const label = compactFormatter.format(components.year);
            const era = components.era === 1 ? "CE" : "BCE";
            return `Year ${label} ${era}`;
        }

        function formatTickLabel(minutes) {
            if (minutes === 0) {
                return "Center";
            }
            
            // Use the fine granularity for tick labels
            const granularity = getCurrentFineGranularity();
            
            // For large time scales (Eon, Epoch, Age, Millennium, Century, Decade, Year), use year-based format
            if (granularity === "Eon" || granularity === "Epoch" || granularity === "Age" || 
                granularity === "Millennium" || granularity === "Century" || granularity === "Decade" || 
                granularity === "Year") {
                return formatYearLabel(minutes);
            }
            
            // For sub-year granularities, use minutesToDateComponents to get correct date
            const components = minutesToDateComponents(minutes);
            const era = components.era === 1 ? "CE" : "BCE";
            const monthIndex = Math.min(Math.max(components.month - 1, 0), 11);
            
            // Format based on granularity
            if (granularity === "Month") {
                // Show Month and Year
                return `${MONTH_NAMES[monthIndex]} ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Week" || granularity === "Day") {
                // Show Month, Day, and Year
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Hour") {
                // Show Day and Time with Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:00 ${era}`;
            } else {
                // Minute
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:${pad(components.minute)} ${era}`;
            }
        }

        function formatDetailedTime(minutes, granularity) {
            if (minutes === 0) {
                return "Center (Year 1 CE · Month 1 · Day 1 · 00:00)";
            }
            
            const components = minutesToDateComponents(minutes);
            const era = components.era === 1 ? "CE" : "BCE";
            const monthIndex = Math.min(Math.max(components.month - 1, 0), 11);
            
            // Format based on granularity
            if (granularity === "Eon" || granularity === "Epoch" || granularity === "Age" || 
                granularity === "Millennium" || granularity === "Century" || granularity === "Decade") {
                // For very large scales, show year with compact notation
                const yearLabel = compactFormatter.format(components.year);
                return `Year ${yearLabel} ${era}`;
            } else if (granularity === "Year") {
                // Show full year
                return `Year ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Month") {
                // Show Month and Year
                return `${MONTH_NAMES[monthIndex]} ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Week" || granularity === "Day") {
                // Show Month, Day, and Year
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Hour") {
                // Show Day and Time with Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:00 ${era}`;
            } else if (granularity === "Minute") {
                // Show Time with minutes and Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:${pad(components.minute)} ${era}`;
            }

            // Fallback to detailed format
            return `Year ${formatYear(components.year)} ${era} · Month ${components.month} · Day ${components.day} · ${pad(components.hour)}:${pad(components.minute)}`;
        }

        function formatDifference(minutes, granularity) {
            if (minutes === 0) {
                return "Exactly at the center moment.";
            }
            const unitMinutes = GRANULARITY_TO_MINUTES[granularity];
            const diffUnits = minutes / unitMinutes;
            const direction = minutes >= 0 ? "after" : "before";
            const absoluteUnits = Math.abs(diffUnits);
            const formattedUnits = absoluteUnits >= 1000
                ? numberFormatter.format(Math.round(absoluteUnits))
                : absoluteUnits.toFixed(2);
            const unitLabel = getUnitLabel(granularity, Math.abs(absoluteUnits - 1) >= 1e-6, false);
            return `${formattedUnits} ${unitLabel} ${direction} the center moment.`;
        }

        function getUnitLabel(granularity, isPlural, capitalize) {
            const entry = UNIT_LABELS[granularity];
            if (!entry) {
                return granularity;
            }
            const text = isPlural ? entry.plural : entry.singular;
            return capitalize ? text.charAt(0).toUpperCase() + text.slice(1) : text;
        }

        function formatYearInputValue(minutes) {
            const years = minutes / MINUTES_PER_YEAR;
            const rounded = Math.round(years * 1000) / 1000;
            const sanitized = Math.abs(rounded) < 1e-6 ? 0 : rounded;
            return sanitized.toString();
        }

        function pad(value) {
            return value.toString().padStart(2, "0");
        }

        // Calculate minimum span in minutes based on 20px minimum separation
        function calculateMinPixelSpan(wrapperWidth, totalRange) {
            const minPixels = 20; // Minimum pixel separation between handles
            const effectiveWidth = wrapperWidth - 24; // Account for padding
            return (minPixels / effectiveWidth) * totalRange;
        }

        // Range slider functionality
        function updateRangeSliders() {
            updateBottomSlider();
            updateTopSlider();
        }

        function updateBottomSlider() {
            // Bottom slider boundaries are set by the date inputs (viewStartMinutes and viewEndMinutes)
            const totalRange = viewEndMinutes - viewStartMinutes;
            
            // Prevent division by zero
            if (totalRange === 0) {
                bottomStartHandle.style.left = '50%';
                bottomEndHandle.style.left = '50%';
                bottomSelected.style.left = '50%';
                bottomSelected.style.width = '0%';
                bottomInfo.textContent = 'Range: Invalid (date range is zero)';
                return;
            }
            
            const startPercent = ((bottomStartMinutes - viewStartMinutes) / totalRange) * 100;
            const endPercent = ((bottomEndMinutes - viewStartMinutes) / totalRange) * 100;
            
            bottomStartHandle.style.left = `${startPercent}%`;
            bottomEndHandle.style.left = `${endPercent}%`;
            bottomSelected.style.left = `${startPercent}%`;
            bottomSelected.style.width = `${endPercent - startPercent}%`;
            
            // Use fine granularity for labeling
            const granularity = getCurrentFineGranularity();
            const startLabel = formatSliderLabel(bottomStartMinutes, granularity);
            const endLabel = formatSliderLabel(bottomEndMinutes, granularity);
            bottomInfo.textContent = `Range: ${startLabel} to ${endLabel}`;
        }

        function updateTopSlider() {
            const totalRange = bottomEndMinutes - bottomStartMinutes;
            
            // Prevent division by zero
            if (totalRange === 0) {
                topStartHandle.style.left = '50%';
                topEndHandle.style.left = '50%';
                topSelected.style.left = '50%';
                topSelected.style.width = '0%';
                topInfo.textContent = 'Fine range: Invalid (bottom range is zero)';
                return;
            }
            
            const startPercent = ((topStartMinutes - bottomStartMinutes) / totalRange) * 100;
            const endPercent = ((topEndMinutes - bottomStartMinutes) / totalRange) * 100;
            
            topStartHandle.style.left = `${startPercent}%`;
            topEndHandle.style.left = `${endPercent}%`;
            topSelected.style.left = `${startPercent}%`;
            topSelected.style.width = `${endPercent - startPercent}%`;
            
            // Use current fine granularity (manual or auto-calculated)
            const fineGranularity = getCurrentFineGranularity();
            const startLabel = formatSliderLabel(topStartMinutes, fineGranularity);
            const endLabel = formatSliderLabel(topEndMinutes, fineGranularity);
            topInfo.textContent = `Fine range (${fineGranularity}): ${startLabel} to ${endLabel}`;
        }

        // Drag handling for bottom timeline
        let dragState = null;

        function startBottomDrag(type, event) {
            event.preventDefault();
            const rect = bottomSliderWrapper.getBoundingClientRect();
            // Bottom slider boundaries are set by the date inputs
            const totalRange = viewEndMinutes - viewStartMinutes;
            
            dragState = {
                type: type,
                timeline: 'bottom',
                startX: event.clientX,
                startMinutesStart: bottomStartMinutes,
                startMinutesEnd: bottomEndMinutes,
                wrapperRect: rect,
                totalRange: totalRange,
                boundaryMin: viewStartMinutes,
                boundaryMax: viewEndMinutes
            };
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', endDrag);
        }

        function startTopDrag(type, event) {
            event.preventDefault();
            const rect = topSliderWrapper.getBoundingClientRect();
            const totalRange = bottomEndMinutes - bottomStartMinutes;
            
            dragState = {
                type: type,
                timeline: 'top',
                startX: event.clientX,
                startMinutesStart: topStartMinutes,
                startMinutesEnd: topEndMinutes,
                wrapperRect: rect,
                totalRange: totalRange
            };
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', endDrag);
        }

        function handleDrag(event) {
            if (!dragState) return;
            
            const deltaX = event.clientX - dragState.startX;
            const wrapperWidth = dragState.wrapperRect.width - 24; // Account for padding
            const deltaPercent = deltaX / wrapperWidth;
            const deltaMinutes = deltaPercent * dragState.totalRange;
            
            if (dragState.timeline === 'bottom') {
                handleBottomDrag(deltaMinutes);
            } else {
                handleTopDrag(deltaMinutes);
            }
        }

        function handleBottomDrag(deltaMinutes) {
            const boundaryMin = dragState.boundaryMin || viewStartMinutes;
            const boundaryMax = dragState.boundaryMax || viewEndMinutes;
            const minBottomSpan = 1440; // 1 day minimum span
            
            // Calculate minimum span based on 20px minimum separation
            const minPixelSpan = calculateMinPixelSpan(dragState.wrapperRect.width, dragState.totalRange);
            
            // Use the larger of the time-based minimum or the pixel-based minimum
            const effectiveMinSpan = Math.max(minBottomSpan, minPixelSpan);
            
            if (dragState.type === 'start') {
                let newStart = dragState.startMinutesStart + deltaMinutes;
                // Constrain within date input boundaries
                newStart = Math.max(boundaryMin, Math.min(newStart, bottomEndMinutes - effectiveMinSpan));
                newStart = Math.max(boundaryMin, newStart); // Ensure it doesn't go below min
                bottomStartMinutes = newStart;
                
                // If start moved, ensure end respects boundaries too
                if (bottomEndMinutes > boundaryMax) {
                    bottomEndMinutes = boundaryMax;
                }
                if (bottomEndMinutes - bottomStartMinutes < effectiveMinSpan) {
                    bottomEndMinutes = Math.min(boundaryMax, bottomStartMinutes + effectiveMinSpan);
                }
                
                // Constrain top timeline within new bottom bounds
                const bottomSpan = bottomEndMinutes - bottomStartMinutes;
                const fineGranularity = getCurrentFineGranularity();
                const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
                topStartMinutes = Math.max(bottomStartMinutes, Math.min(topStartMinutes, bottomEndMinutes - minTopSpan));
                topEndMinutes = Math.min(bottomEndMinutes, Math.max(topEndMinutes, topStartMinutes + minTopSpan));
            } else if (dragState.type === 'end') {
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                // Constrain within date input boundaries
                newEnd = Math.min(boundaryMax, Math.max(newEnd, bottomStartMinutes + effectiveMinSpan));
                newEnd = Math.min(boundaryMax, newEnd); // Ensure it doesn't go above max
                bottomEndMinutes = newEnd;
                
                // If end moved, ensure start respects boundaries too
                if (bottomStartMinutes < boundaryMin) {
                    bottomStartMinutes = boundaryMin;
                }
                if (bottomEndMinutes - bottomStartMinutes < effectiveMinSpan) {
                    bottomStartMinutes = Math.max(boundaryMin, bottomEndMinutes - effectiveMinSpan);
                }
                
                // Constrain top timeline within new bottom bounds
                const bottomSpan = bottomEndMinutes - bottomStartMinutes;
                const fineGranularity = getCurrentFineGranularity();
                const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
                topStartMinutes = Math.max(bottomStartMinutes, Math.min(topStartMinutes, bottomEndMinutes - minTopSpan));
                topEndMinutes = Math.min(bottomEndMinutes, Math.max(topEndMinutes, topStartMinutes + minTopSpan));
            } else if (dragState.type === 'range') {
                const span = dragState.startMinutesEnd - dragState.startMinutesStart;
                
                // Prevent division by zero
                if (span === 0) {
                    return;
                }
                
                let newStart = dragState.startMinutesStart + deltaMinutes;
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                
                // Keep within date input boundaries
                if (newStart < boundaryMin) {
                    newStart = boundaryMin;
                    newEnd = newStart + span;
                }
                if (newEnd > boundaryMax) {
                    newEnd = boundaryMax;
                    newStart = newEnd - span;
                }
                
                // Double-check both are within bounds
                newStart = Math.max(boundaryMin, Math.min(newStart, boundaryMax - span));
                newEnd = Math.min(boundaryMax, Math.max(newEnd, boundaryMin + span));
                
                bottomStartMinutes = newStart;
                bottomEndMinutes = newEnd;
                
                // Move top timeline proportionally
                const topSpan = topEndMinutes - topStartMinutes;
                const dragSpan = dragState.startMinutesEnd - dragState.startMinutesStart;
                
                // This check should never fail since we already checked above, but adding for safety
                if (dragSpan !== 0) {
                    const topRelativeStart = (topStartMinutes - dragState.startMinutesStart) / dragSpan;
                    topStartMinutes = bottomStartMinutes + topRelativeStart * (bottomEndMinutes - bottomStartMinutes);
                    topEndMinutes = topStartMinutes + topSpan;
                }
                
                // Ensure top stays within bottom bounds
                topStartMinutes = Math.max(bottomStartMinutes, Math.min(topStartMinutes, bottomEndMinutes - topSpan));
                topEndMinutes = topStartMinutes + topSpan;
            }
            
            updateRangeSliders();
            // Update the main view display to show the top timeline's range
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        function handleTopDrag(deltaMinutes) {
            const fineGranularity = getCurrentFineGranularity();
            const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
            
            // Calculate minimum span based on 20px minimum separation
            const minPixelSpan = calculateMinPixelSpan(dragState.wrapperRect.width, dragState.totalRange);
            
            // Use the larger of the time-based minimum or the pixel-based minimum
            const effectiveMinSpan = Math.max(minTopSpan, minPixelSpan);
            
            if (dragState.type === 'start') {
                let newStart = dragState.startMinutesStart + deltaMinutes;
                newStart = Math.max(bottomStartMinutes, newStart);
                newStart = Math.min(newStart, topEndMinutes - effectiveMinSpan);
                topStartMinutes = newStart;
            } else if (dragState.type === 'end') {
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                newEnd = Math.min(bottomEndMinutes, newEnd);
                newEnd = Math.max(newEnd, topStartMinutes + effectiveMinSpan);
                topEndMinutes = newEnd;
            } else if (dragState.type === 'range') {
                const span = dragState.startMinutesEnd - dragState.startMinutesStart;
                let newStart = dragState.startMinutesStart + deltaMinutes;
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                
                // Keep within bottom timeline bounds
                if (newStart < bottomStartMinutes) {
                    newStart = bottomStartMinutes;
                    newEnd = newStart + span;
                }
                if (newEnd > bottomEndMinutes) {
                    newEnd = bottomEndMinutes;
                    newStart = newEnd - span;
                }
                
                topStartMinutes = newStart;
                topEndMinutes = newEnd;
            }
            
            updateRangeSliders();
            // Update the main view display to show the top timeline's range
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        function endDrag() {
            dragState = null;
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', endDrag);
        }

        function updateViewFromTopTimeline() {
            viewStartMinutes = topStartMinutes;
            viewEndMinutes = topEndMinutes;
            currentViewMinutes = (topStartMinutes + topEndMinutes) / 2;
            
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        // Event listeners for bottom timeline
        bottomStartHandle.addEventListener('mousedown', (e) => startBottomDrag('start', e));
        bottomEndHandle.addEventListener('mousedown', (e) => startBottomDrag('end', e));
        bottomSelected.addEventListener('mousedown', (e) => startBottomDrag('range', e));

        // Event listeners for top timeline
        topStartHandle.addEventListener('mousedown', (e) => startTopDrag('start', e));
        topEndHandle.addEventListener('mousedown', (e) => startTopDrag('end', e));
        topSelected.addEventListener('mousedown', (e) => startTopDrag('range', e));

        // Apply button handlers
        applyStartBtn.addEventListener("click", () => {
            updateViewRange();
        });

        applyEndBtn.addEventListener("click", () => {
            updateViewRange();
        });

        // Add event listeners to all date component inputs
        const allDateInputs = [
            startEra, startYearComp, startMonth, startDay, startHour, startMinute,
            endEra, endYearComp, endMonth, endDay, endHour, endMinute
        ];
        
        allDateInputs.forEach(input => {
            input.addEventListener("change", () => {
                updateViewRange();
            });
            input.addEventListener("keydown", event => {
                if (event.key === "Enter") {
                    updateViewRange();
                }
            });
        });

        // Fine granularity controls
        const fineGranularitySelect = document.getElementById("fineGranularitySelect");
        const applyTopGranularityBtn = document.getElementById("applyTopGranularityBtn");
        
        // Function to apply manual fine granularity override
        function applyFineGranularity() {
            const selectedGranularity = fineGranularitySelect.value;
            
            // Set the manual override
            manualFineGranularity = selectedGranularity;
            
            const minTopSpan = GRANULARITY_TO_MINUTES[selectedGranularity] * 10; // At least 10 units
            
            // Calculate new top slider span based on selected granularity
            const bottomSpan = bottomEndMinutes - bottomStartMinutes;
            
            // Try to use 1/4 of bottom span, but ensure at least 10 units of selected granularity
            let targetTopSpan = Math.max(bottomSpan / 4, minTopSpan);
            
            // Ensure it doesn't exceed bottom span
            if (targetTopSpan > bottomSpan) {
                targetTopSpan = bottomSpan;
            }
            
            // Center the new top slider range within bottom slider
            const bottomMidpoint = (bottomStartMinutes + bottomEndMinutes) / 2;
            const halfSpan = targetTopSpan / 2;
            
            topStartMinutes = Math.max(bottomStartMinutes, bottomMidpoint - halfSpan);
            topEndMinutes = Math.min(bottomEndMinutes, bottomMidpoint + halfSpan);
            
            // If we hit boundaries, adjust
            if (topEndMinutes - topStartMinutes < minTopSpan) {
                topEndMinutes = Math.min(bottomEndMinutes, topStartMinutes + minTopSpan);
                if (topEndMinutes - topStartMinutes < minTopSpan) {
                    topStartMinutes = Math.max(bottomStartMinutes, topEndMinutes - minTopSpan);
                }
            }
            
            updateRangeSliders();
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }
        
        applyTopGranularityBtn.addEventListener("click", applyFineGranularity);
        
        // Update the fine granularity select to show the current granularity
        function updateFineGranularitySelects() {
            const currentFineGranularity = getCurrentFineGranularity();
            fineGranularitySelect.value = currentFineGranularity;
        }

        // Initialize
        initializeTimelines();
        updateDateInputs();
        updateRangeSliders();
        refreshRangeDisplay();
        rebuildTicks();
        updatePointerAndDetails();
        updateFineGranularitySelects();
    </script>
</body>
</html>
