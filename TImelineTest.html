<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Deep Time Timeline Explorer</title>
    <style>
        :root {
            color-scheme: light;
            font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            --accent: #0ea5e9;
            --accent-dark: #0284c7;
            --surface: rgba(255, 255, 255, 0.88);
            --shadow: 0 25px 60px rgba(15, 23, 42, 0.18);
            --text-muted: #475569;
            --future-accent: #a855f7;
            --future-accent-dark: #7e22ce;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem 1.5rem;
            background: radial-gradient(circle at top, #f0f9ff, #dbeafe 45%, #c7d2fe 100%);
            color: #0f172a;
        }

        .app {
            width: min(1080px, 100%);
            background: var(--surface);
            border-radius: 28px;
            overflow: hidden;
            box-shadow: var(--shadow);
            backdrop-filter: blur(12px);
        }

        header {
            padding: 2.5rem 3rem 2rem;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.9), rgba(6, 182, 212, 0.9));
            color: white;
        }

        header h1 {
            margin: 0 0 0.75rem;
            font-size: clamp(2rem, 3vw, 2.6rem);
            letter-spacing: 0.02em;
        }

        header p {
            margin: 0;
            max-width: 720px;
            font-size: 1.05rem;
            line-height: 1.6;
        }

        .panel {
            padding: 2.5rem 3rem 2rem;
            background: rgba(248, 250, 252, 0.9);
        }

        .control-grid {
            display: grid;
            gap: 1.8rem;
        }

        .control-row {
            display: grid;
            gap: 0.5rem;
        }

        label {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        select,
        input[type="number"] {
            width: 100%;
            border-radius: 14px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            padding: 0.9rem 1rem;
            font-size: 1rem;
            transition: border 0.2s ease, box-shadow 0.2s ease;
            background: white;
        }

        select:focus,
        input[type="number"]:focus {
            outline: none;
            border-color: rgba(14, 165, 233, 0.7);
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2);
        }

        .control-row input[type="range"] {
            width: 100%;
            margin-top: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .date-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .date-field {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .field-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .date-field input[type="number"],
        .date-field select {
            padding: 0.6rem 0.5rem;
            font-size: 0.9rem;
        }

        .hint {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .controls-footer {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
        }

        button {
            border: none;
            border-radius: 999px;
            padding: 0.85rem 1.6rem;
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: white;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 15px 30px rgba(2, 132, 199, 0.25);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 20px 40px rgba(2, 132, 199, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .timeline-card {
            padding: 2.5rem 3rem 3rem;
            display: grid;
            gap: 1.5rem;
            background: white;
        }

        .timeline-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem 2rem;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        .timeline-meta strong {
            color: #0f172a;
        }

        .range-display {
            border-radius: 18px;
            padding: 1rem 1.25rem;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.08), rgba(59, 130, 246, 0.12));
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .slider-area {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .slider-area label {
            color: #0f172a;
        }

        .dual-timeline-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            margin-top: 1rem;
        }

        .range-slider-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .range-slider-label {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        .range-slider-wrapper {
            position: relative;
            height: 50px;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.15), rgba(37, 99, 235, 0.15));
            border-radius: 12px;
            padding: 0 12px;
            flex: 1;
        }

        .range-slider-track {
            position: absolute;
            top: 50%;
            left: 12px;
            right: 12px;
            height: 8px;
            transform: translateY(-50%);
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.3);
        }

        .range-slider-selected {
            position: absolute;
            top: 50%;
            height: 8px;
            transform: translateY(-50%);
            border-radius: 999px;
            background: linear-gradient(90deg, var(--accent), var(--accent-dark));
            cursor: grab;
        }

        .range-slider-selected:active {
            cursor: grabbing;
        }

        .range-slider-selected.future {
            background: linear-gradient(90deg, var(--future-accent), var(--future-accent-dark));
        }

        .range-handle {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(14, 165, 233, 0.3);
            border: 3px solid white;
            z-index: 10;
        }

        .range-handle:hover {
            transform: translate(-50%, -50%) scale(1.15);
        }

        .range-handle:active {
            transform: translate(-50%, -50%) scale(1.05);
        }

        .range-handle.future {
            background: linear-gradient(135deg, var(--future-accent), var(--future-accent-dark));
            box-shadow: 0 8px 16px rgba(168, 85, 247, 0.3);
        }

        /* Wrapper for slider and boundary controls */
        .range-slider-with-controls {
            position: relative;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Slider boundary control wrappers outside of slider track */
        .slider-boundary-control {
            position: relative;
            z-index: 100;
            flex-shrink: 0;
        }

        .slider-boundary-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(14, 165, 233, 0.3);
            border: 3px solid white;
            transition: transform 0.2s ease;
        }

        .slider-boundary-icon:hover {
            transform: scale(1.1);
        }

        .slider-boundary-icon span {
            font-size: 16px;
            color: white;
        }

        .range-controls {
            position: absolute;
            top: -91px;
            background: white;
            border-radius: 14px;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.25);
            padding: 1rem;
            min-width: 420px;
            max-width: calc(100vw - 40px);
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease 0.15s, visibility 0s linear 0.35s;
            border: 1px solid rgba(148, 163, 184, 0.25);
            z-index: 100;
        }
        
        /* Position start control popup */
        #sliderStartControl .range-controls {
            left: calc(100% + 8px);
            transform-origin: left top;
        }
        
        /* Position end control popup to not overflow right */
        #sliderEndControl .range-controls {
            right: calc(100% + 8px);
            left: auto;
            transform-origin: right top;
        }
        
        /* Add invisible bridge to maintain hover state */
        .range-controls::before {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 16px;
            background: transparent;
        }
        
        /* Position bridge on appropriate side */
        #sliderStartControl .range-controls::before {
            right: 100%;
        }
        
        #sliderEndControl .range-controls::before {
            left: 100%;
        }

        /* Keep popup visible with delay when hovering either icon or popup */
        .slider-boundary-control:hover .range-controls {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.2s ease, visibility 0s linear;
        }

        .range-controls:hover {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.2s ease, visibility 0s linear;
        }

        .range-slider-info {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* Geologic period segments */
        .geologic-segments-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            border-radius: 999px;
            overflow: hidden;
        }

        .geologic-segment {
            position: absolute;
            height: 100%;
            cursor: pointer;
            transition: opacity 0.2s ease, filter 0.2s ease;
            border-right: 1px solid rgba(0, 0, 0, 0.1);
        }

        .geologic-segment:hover {
            filter: brightness(1.15);
            opacity: 0.95;
            z-index: 5;
        }

        /* Geologic period tooltip */
        .geologic-tooltip {
            position: fixed;
            background: white;
            border-radius: 12px;
            padding: 1rem 1.25rem;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.25);
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease;
            border: 1px solid rgba(148, 163, 184, 0.25);
            max-width: 300px;
        }

        .geologic-tooltip.visible {
            opacity: 1;
        }

        .geologic-tooltip-header {
            font-weight: 700;
            font-size: 1rem;
            color: #0f172a;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid;
        }

        .geologic-tooltip-row {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.35rem;
            font-size: 0.9rem;
        }

        .geologic-tooltip-label {
            font-weight: 600;
            color: var(--text-muted);
            min-width: 60px;
        }

        .geologic-tooltip-value {
            color: #0f172a;
        }

        .geologic-tooltip-dates {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(148, 163, 184, 0.2);
            font-size: 0.85rem;
            color: var(--text-muted);
            font-style: italic;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 14px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.25), rgba(37, 99, 235, 0.25));
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 12px 20px rgba(14, 165, 233, 0.25);
            border: 3px solid white;
        }

        input[type="range"]::-moz-range-thumb {
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 12px 20px rgba(14, 165, 233, 0.25);
            border: 3px solid white;
        }

        .timeline {
            position: relative;
            border-radius: 22px;
            padding: 3.2rem 2.2rem 3.5rem;
            background: radial-gradient(circle at top, rgba(14, 165, 233, 0.12), rgba(59, 130, 246, 0.08)),
                linear-gradient(135deg, rgba(148, 163, 184, 0.2), rgba(148, 163, 184, 0.05));
            overflow: visible;
        }

        .timeline-inner {
            position: relative;
            margin: 0 2rem;
        }

        .timeline-track {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 10px;
            transform: translateY(-50%);
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.3), rgba(2, 132, 199, 0.6), rgba(14, 165, 233, 0.3));
            box-shadow: inset 0 0 12px rgba(14, 165, 233, 0.35);
        }

        .timeline-ticks {
            position: relative;
            min-height: 140px;
        }

        .tick {
            position: absolute;
            top: 0;
            transform: translateX(-50%);
            text-align: center;
            color: var(--text-muted);
            width: 120px;
        }

        .tick.future .tick-line {
            background: linear-gradient(180deg, rgba(168, 85, 247, 0.25), rgba(168, 85, 247, 0));
        }

        .tick.future .tick-label {
            color: #7e22ce;
        }

        .tick-line {
            display: block;
            margin: 0 auto 0.6rem;
            width: 2px;
            height: 32px;
            background: linear-gradient(180deg, rgba(14, 165, 233, 0.25), rgba(14, 165, 233, 0));
        }

        .tick-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #1e293b;
            text-shadow: 0 1px 2px rgba(148, 163, 184, 0.35);
            display: block;
            line-height: 1.3;
        }

        .pointer {
            position: absolute;
            top: 28%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.4rem;
            pointer-events: none;
        }

        .pointer::after {
            content: "";
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            box-shadow: 0 0 0 8px rgba(14, 165, 233, 0.18);
        }

        .pointer-label {
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.92), rgba(2, 132, 199, 0.92));
            color: white;
            font-size: 0.78rem;
            letter-spacing: 0.03em;
            text-transform: uppercase;
            box-shadow: 0 12px 24px rgba(14, 165, 233, 0.35);
        }

        .current-time {
            border-radius: 20px;
            padding: 1.5rem 1.75rem;
            background: linear-gradient(135deg, rgba(240, 249, 255, 0.7), rgba(224, 242, 254, 0.85));
            box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.25);
            display: grid;
            gap: 0.65rem;
            font-size: 1rem;
        }

        .current-time h3 {
            margin: 0;
            font-size: 1.05rem;
            color: #0f172a;
            letter-spacing: 0.01em;
        }

        .current-time span {
            color: var(--text-muted);
        }

        .footnote {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.6;
        }

        @media (min-width: 720px) {
            .control-grid {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }

            .control-row:nth-child(2),
            .control-row:nth-child(3) {
                grid-column: span 1;
            }

            .controls-footer {
                grid-column: span 3;
                justify-content: space-between;
            }
        }

        @media (max-width: 640px) {
            header,
            .panel,
            .timeline-card {
                padding: 2rem 1.5rem;
            }

            .tick {
                width: 96px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <section class="timeline-card">
            <div class="range-display" id="rangeDisplay"></div>
            <div class="dual-timeline-container">
                <!-- Top Timeline: Fine Range Selector -->
                <div class="range-slider-container">
                    <div class="range-slider-with-controls">
                        <div class="range-slider-wrapper" id="topSliderWrapper">
                            <div class="range-slider-track" id="topSliderTrack">
                                <div class="geologic-segments-container" id="topGeologicSegments"></div>
                            </div>
                            <div class="range-slider-selected" id="topSelected"></div>
                            <div class="range-handle" id="topStartHandle"></div>
                            <div class="range-handle" id="topEndHandle"></div>
                        </div>
                    </div>
                </div>

                <!-- Bottom Timeline: Coarse Range Selector -->
                <div class="range-slider-container">
                    <div class="range-slider-with-controls">
                        <!-- View Start Control at left side -->
                        <div class="slider-boundary-control" id="sliderStartControl">
                            <div class="slider-boundary-icon">
                                <span>⚙</span>
                            </div>
                            <div class="range-controls" id="startControls">
                                <div class="date-inputs">
                                    <div class="date-field">
                                        <label for="startEra" class="field-label">Era</label>
                                        <select id="startEra">
                                            <option value="-1">BCE</option>
                                            <option value="1">CE</option>
                                        </select>
                                    </div>
                                    <div class="date-field">
                                        <label for="startYearComp" class="field-label">Year</label>
                                        <input type="number" id="startYearComp" value="1000001" min="1" max="4540000000" />
                                    </div>
                                    <div class="date-field">
                                        <label for="startMonth" class="field-label">Month</label>
                                        <input type="number" id="startMonth" value="1" min="1" max="12" />
                                    </div>
                                    <div class="date-field">
                                        <label for="startDay" class="field-label">Day</label>
                                        <input type="number" id="startDay" value="1" min="1" max="31" />
                                    </div>
                                    <div class="date-field">
                                        <label for="startHour" class="field-label">Hour</label>
                                        <input type="number" id="startHour" value="0" min="0" max="23" />
                                    </div>
                                    <div class="date-field">
                                        <label for="startMinute" class="field-label">Minute</label>
                                        <input type="number" id="startMinute" value="0" min="0" max="59" />
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="range-slider-wrapper" id="bottomSliderWrapper">
                            <div class="range-slider-track" id="bottomSliderTrack">
                                <div class="geologic-segments-container" id="bottomGeologicSegments"></div>
                            </div>
                            <div class="range-slider-selected" id="bottomSelected"></div>
                            <div class="range-handle" id="bottomStartHandle"></div>
                            <div class="range-handle" id="bottomEndHandle"></div>
                        </div>
                        <!-- View End Control at right side -->
                        <div class="slider-boundary-control" id="sliderEndControl">
                            <div class="slider-boundary-icon">
                                <span>⚙</span>
                            </div>
                            <div class="range-controls" id="endControls">
                                <div class="date-inputs">
                                    <div class="date-field">
                                        <label for="endEra" class="field-label">Era</label>
                                        <select id="endEra">
                                            <option value="-1">BCE</option>
                                            <option value="1" selected>CE</option>
                                        </select>
                                    </div>
                                    <div class="date-field">
                                        <label for="endYearComp" class="field-label">Year</label>
                                        <input type="number" id="endYearComp" value="1000001" min="1" max="4540000000" />
                                    </div>
                                    <div class="date-field">
                                        <label for="endMonth" class="field-label">Month</label>
                                        <input type="number" id="endMonth" value="1" min="1" max="12" />
                                    </div>
                                    <div class="date-field">
                                        <label for="endDay" class="field-label">Day</label>
                                        <input type="number" id="endDay" value="1" min="1" max="31" />
                                    </div>
                                    <div class="date-field">
                                        <label for="endHour" class="field-label">Hour</label>
                                        <input type="number" id="endHour" value="0" min="0" max="23" />
                                    </div>
                                    <div class="date-field">
                                        <label for="endMinute" class="field-label">Minute</label>
                                        <input type="number" id="endMinute" value="0" min="0" max="59" />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <!-- Geologic period tooltip -->
    <div class="geologic-tooltip" id="geologicTooltip">
        <div class="geologic-tooltip-header" id="tooltipHeader"></div>
        <div class="geologic-tooltip-row">
            <span class="geologic-tooltip-label">Eon:</span>
            <span class="geologic-tooltip-value" id="tooltipEon"></span>
        </div>
        <div class="geologic-tooltip-row">
            <span class="geologic-tooltip-label">Era:</span>
            <span class="geologic-tooltip-value" id="tooltipEra"></span>
        </div>
        <div class="geologic-tooltip-row">
            <span class="geologic-tooltip-label">Period:</span>
            <span class="geologic-tooltip-value" id="tooltipPeriod"></span>
        </div>
        <div class="geologic-tooltip-row">
            <span class="geologic-tooltip-label">Epoch:</span>
            <span class="geologic-tooltip-value" id="tooltipEpoch"></span>
        </div>
        <div class="geologic-tooltip-dates" id="tooltipDates"></div>
    </div>

    <script>
        const MINUTES_PER_YEAR = 525600;
        const MINUTES_PER_MONTH = MINUTES_PER_YEAR / 12;
        const MINUTES_PER_WEEK = 10080;
        const MINUTES_PER_DAY = 1440;
        const MINUTES_PER_HOUR = 60;

        const EARTH_AGE_YEARS = 4_540_000_000;
        const HALF_SPAN_MINUTES = EARTH_AGE_YEARS * MINUTES_PER_YEAR;
        const TIMELINE_MIN = -HALF_SPAN_MINUTES;
        const TIMELINE_MAX = HALF_SPAN_MINUTES;

        // Calculate current date in timeline minutes
        function getCurrentDateMinutes() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth() + 1; // JavaScript months are 0-indexed
            const day = now.getDate();
            const hour = now.getHours();
            const minute = now.getMinutes();
            
            // Year 1 CE is at 0 minutes, so we calculate from there
            let totalMinutes = (year - 1) * MINUTES_PER_YEAR;
            totalMinutes += (month - 1) * MINUTES_PER_MONTH;
            totalMinutes += (day - 1) * MINUTES_PER_DAY;
            totalMinutes += hour * MINUTES_PER_HOUR;
            totalMinutes += minute;
            
            return totalMinutes;
        }
        
        const CURRENT_DATE_MINUTES = getCurrentDateMinutes();
        
        // Calculate default range: from last week to tomorrow night
        const LAST_WEEK_MINUTES = CURRENT_DATE_MINUTES - (7 * MINUTES_PER_DAY);
        // Tomorrow night = end of tomorrow day (23:59)
        // First, calculate minutes elapsed today
        const now = new Date();
        const minutesTodaySoFar = now.getHours() * MINUTES_PER_HOUR + now.getMinutes();
        // Tomorrow night is: go back to start of today, forward 2 days, minus 1 minute
        const TOMORROW_NIGHT_MINUTES = CURRENT_DATE_MINUTES - minutesTodaySoFar + (2 * MINUTES_PER_DAY) - 1;

        const GRANULARITY_TO_MINUTES = {
            Eon: MINUTES_PER_YEAR * 500_000_000,
            Epoch: MINUTES_PER_YEAR * 50_000_000,
            Age: MINUTES_PER_YEAR * 5_000_000,
            Millennium: MINUTES_PER_YEAR * 1_000,
            Century: MINUTES_PER_YEAR * 100,
            Decade: MINUTES_PER_YEAR * 10,
            Year: MINUTES_PER_YEAR,
            Month: MINUTES_PER_MONTH,
            Week: MINUTES_PER_WEEK,
            Day: MINUTES_PER_DAY,
            Hour: MINUTES_PER_HOUR,
            Minute: 1
        };

        const UNIT_LABELS = {
            Eon: { singular: "eon", plural: "eons" },
            Epoch: { singular: "epoch", plural: "epochs" },
            Age: { singular: "age", plural: "ages" },
            Millennium: { singular: "millennium", plural: "millennia" },
            Century: { singular: "century", plural: "centuries" },
            Decade: { singular: "decade", plural: "decades" },
            Year: { singular: "year", plural: "years" },
            Month: { singular: "month", plural: "months" },
            Week: { singular: "week", plural: "weeks" },
            Day: { singular: "day", plural: "days" },
            Hour: { singular: "hour", plural: "hours" },
            Minute: { singular: "minute", plural: "minutes" }
        };

        // Geologic Time Periods Data
        // Based on the International Commission on Stratigraphy (ICS) timescale
        // All dates are in millions of years ago (Ma), converted to BCE years
        // Note: BCE years are negative in our timeline system
        const GEOLOGIC_PERIODS = [
            // PHANEROZOIC EON
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Quaternary",
                epoch: "Holocene",
                startMya: 0.0117,
                endMya: 0,
                color: "#FEF2E0"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Quaternary",
                epoch: "Pleistocene",
                startMya: 2.58,
                endMya: 0.0117,
                color: "#FFF2CC"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Neogene",
                epoch: "Pliocene",
                startMya: 5.333,
                endMya: 2.58,
                color: "#FFFF99"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Neogene",
                epoch: "Miocene",
                startMya: 23.03,
                endMya: 5.333,
                color: "#FFFF00"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Paleogene",
                epoch: "Oligocene",
                startMya: 33.9,
                endMya: 23.03,
                color: "#FED8B1"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Paleogene",
                epoch: "Eocene",
                startMya: 56.0,
                endMya: 33.9,
                color: "#FDC07A"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Paleogene",
                epoch: "Paleocene",
                startMya: 66.0,
                endMya: 56.0,
                color: "#FDA75F"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Cretaceous",
                epoch: "Late Cretaceous",
                startMya: 100.5,
                endMya: 66.0,
                color: "#7FC64E"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Cretaceous",
                epoch: "Early Cretaceous",
                startMya: 145.0,
                endMya: 100.5,
                color: "#8FD14F"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Jurassic",
                epoch: "Late Jurassic",
                startMya: 163.5,
                endMya: 145.0,
                color: "#34B2C9"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Jurassic",
                epoch: "Middle Jurassic",
                startMya: 174.7,
                endMya: 163.5,
                color: "#5FC4D3"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Jurassic",
                epoch: "Early Jurassic",
                startMya: 201.4,
                endMya: 174.7,
                color: "#7AD5DD"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Triassic",
                epoch: "Late Triassic",
                startMya: 237.0,
                endMya: 201.4,
                color: "#983999"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Triassic",
                epoch: "Middle Triassic",
                startMya: 247.2,
                endMya: 237.0,
                color: "#B051A5"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Triassic",
                epoch: "Early Triassic",
                startMya: 251.9,
                endMya: 247.2,
                color: "#C869B0"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Permian",
                epoch: "Lopingian",
                startMya: 259.1,
                endMya: 251.9,
                color: "#F04028"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Permian",
                epoch: "Guadalupian",
                startMya: 273.0,
                endMya: 259.1,
                color: "#F36E4C"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Permian",
                epoch: "Cisuralian",
                startMya: 298.9,
                endMya: 273.0,
                color: "#F69A70"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Carboniferous",
                epoch: "Pennsylvanian",
                startMya: 323.2,
                endMya: 298.9,
                color: "#67A599"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Carboniferous",
                epoch: "Mississippian",
                startMya: 358.9,
                endMya: 323.2,
                color: "#8CB4A9"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Devonian",
                epoch: "Late Devonian",
                startMya: 382.7,
                endMya: 358.9,
                color: "#CB8C37"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Devonian",
                epoch: "Middle Devonian",
                startMya: 393.3,
                endMya: 382.7,
                color: "#D9A85A"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Devonian",
                epoch: "Early Devonian",
                startMya: 419.2,
                endMya: 393.3,
                color: "#E7C37D"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Silurian",
                epoch: "Pridoli",
                startMya: 423.0,
                endMya: 419.2,
                color: "#B3E1E6"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Silurian",
                epoch: "Ludlow",
                startMya: 427.4,
                endMya: 423.0,
                color: "#B3E1E6"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Silurian",
                epoch: "Wenlock",
                startMya: 433.4,
                endMya: 427.4,
                color: "#B3E1E6"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Silurian",
                epoch: "Llandovery",
                startMya: 443.8,
                endMya: 433.4,
                color: "#B3E1E6"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Ordovician",
                epoch: "Late Ordovician",
                startMya: 458.4,
                endMya: 443.8,
                color: "#009270"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Ordovician",
                epoch: "Middle Ordovician",
                startMya: 470.0,
                endMya: 458.4,
                color: "#26A789"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Ordovician",
                epoch: "Early Ordovician",
                startMya: 485.4,
                endMya: 470.0,
                color: "#4DBCA2"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Cambrian",
                epoch: "Furongian",
                startMya: 497.0,
                endMya: 485.4,
                color: "#7FA056"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Cambrian",
                epoch: "Series 3",
                startMya: 509.0,
                endMya: 497.0,
                color: "#8DB06C"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Cambrian",
                epoch: "Series 2",
                startMya: 521.0,
                endMya: 509.0,
                color: "#9BC082"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Cambrian",
                epoch: "Terreneuvian",
                startMya: 538.8,
                endMya: 521.0,
                color: "#A9D098"
            },
            // PROTEROZOIC EON
            {
                eon: "Proterozoic",
                era: "Neoproterozoic",
                period: "Ediacaran",
                epoch: "Ediacaran",
                startMya: 635.0,
                endMya: 538.8,
                color: "#FED99C"
            },
            {
                eon: "Proterozoic",
                era: "Neoproterozoic",
                period: "Cryogenian",
                epoch: "Cryogenian",
                startMya: 720.0,
                endMya: 635.0,
                color: "#FECC9F"
            },
            {
                eon: "Proterozoic",
                era: "Neoproterozoic",
                period: "Tonian",
                epoch: "Tonian",
                startMya: 1000.0,
                endMya: 720.0,
                color: "#FEBFA2"
            },
            {
                eon: "Proterozoic",
                era: "Mesoproterozoic",
                period: "Stenian",
                epoch: "Stenian",
                startMya: 1200.0,
                endMya: 1000.0,
                color: "#FDB46C"
            },
            {
                eon: "Proterozoic",
                era: "Mesoproterozoic",
                period: "Ectasian",
                epoch: "Ectasian",
                startMya: 1400.0,
                endMya: 1200.0,
                color: "#FCA75B"
            },
            {
                eon: "Proterozoic",
                era: "Mesoproterozoic",
                period: "Calymmian",
                epoch: "Calymmian",
                startMya: 1600.0,
                endMya: 1400.0,
                color: "#FC9A4A"
            },
            {
                eon: "Proterozoic",
                era: "Paleoproterozoic",
                period: "Statherian",
                epoch: "Statherian",
                startMya: 1800.0,
                endMya: 1600.0,
                color: "#F48C61"
            },
            {
                eon: "Proterozoic",
                era: "Paleoproterozoic",
                period: "Orosirian",
                epoch: "Orosirian",
                startMya: 2050.0,
                endMya: 1800.0,
                color: "#F27E75"
            },
            {
                eon: "Proterozoic",
                era: "Paleoproterozoic",
                period: "Rhyacian",
                epoch: "Rhyacian",
                startMya: 2300.0,
                endMya: 2050.0,
                color: "#F07089"
            },
            {
                eon: "Proterozoic",
                era: "Paleoproterozoic",
                period: "Siderian",
                epoch: "Siderian",
                startMya: 2500.0,
                endMya: 2300.0,
                color: "#EF629D"
            },
            // ARCHEAN EON
            {
                eon: "Archean",
                era: "Neoarchean",
                period: "Neoarchean",
                epoch: "Neoarchean",
                startMya: 2800.0,
                endMya: 2500.0,
                color: "#F2A4C6"
            },
            {
                eon: "Archean",
                era: "Mesoarchean",
                period: "Mesoarchean",
                epoch: "Mesoarchean",
                startMya: 3200.0,
                endMya: 2800.0,
                color: "#F5B5D4"
            },
            {
                eon: "Archean",
                era: "Paleoarchean",
                period: "Paleoarchean",
                epoch: "Paleoarchean",
                startMya: 3600.0,
                endMya: 3200.0,
                color: "#F8C6E2"
            },
            {
                eon: "Archean",
                era: "Eoarchean",
                period: "Eoarchean",
                epoch: "Eoarchean",
                startMya: 4000.0,
                endMya: 3600.0,
                color: "#FBD7F0"
            },
            // HADEAN EON
            {
                eon: "Hadean",
                era: "Hadean",
                period: "Hadean",
                epoch: "Hadean",
                startMya: 4540.0,
                endMya: 4000.0,
                color: "#D4C5C0"
            }
        ];

        // Convert Mya (millions of years ago) to timeline minutes (BCE)
        function myaToMinutes(mya) {
            // Mya = millions of years ago, which are BCE years
            // BCE years are negative in our system
            const yearsAgo = mya * 1_000_000;
            return -yearsAgo * MINUTES_PER_YEAR;
        }

        // Add timeline minutes to each geologic period
        GEOLOGIC_PERIODS.forEach(period => {
            period.startMinutes = myaToMinutes(period.startMya);
            period.endMinutes = myaToMinutes(period.endMya);
        });

        const compactFormatter = new Intl.NumberFormat("en-US", {
            notation: "compact",
            maximumFractionDigits: 1
        });
        const numberFormatter = new Intl.NumberFormat("en-US");
        
        // Custom formatter for years: no commas for 4-digit years (1000-9999)
        function formatYear(year) {
            const absYear = Math.abs(year);
            if (absYear >= 1000 && absYear <= 9999) {
                return absYear.toString();
            }
            return numberFormatter.format(absYear);
        }
        
        const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        
        // Start date components
        const startEra = document.getElementById("startEra");
        const startYearComp = document.getElementById("startYearComp");
        const startMonth = document.getElementById("startMonth");
        const startDay = document.getElementById("startDay");
        const startHour = document.getElementById("startHour");
        const startMinute = document.getElementById("startMinute");
        
        // End date components
        const endEra = document.getElementById("endEra");
        const endYearComp = document.getElementById("endYearComp");
        const endMonth = document.getElementById("endMonth");
        const endDay = document.getElementById("endDay");
        const endHour = document.getElementById("endHour");
        const endMinute = document.getElementById("endMinute");

        const rangeDisplay = document.getElementById("rangeDisplay");

        // Bottom timeline elements
        const bottomSliderWrapper = document.getElementById("bottomSliderWrapper");
        const bottomSliderTrack = document.getElementById("bottomSliderTrack");
        const bottomSelected = document.getElementById("bottomSelected");
        const bottomStartHandle = document.getElementById("bottomStartHandle");
        const bottomEndHandle = document.getElementById("bottomEndHandle");

        // Top timeline elements
        const topSliderWrapper = document.getElementById("topSliderWrapper");
        const topSliderTrack = document.getElementById("topSliderTrack");
        const topSelected = document.getElementById("topSelected");
        const topStartHandle = document.getElementById("topStartHandle");
        const topEndHandle = document.getElementById("topEndHandle");


        // Timeline state
        // Bottom timeline: user's coarse range selection (boundaries are TIMELINE_MIN to TIMELINE_MAX)
        let bottomStartMinutes = LAST_WEEK_MINUTES;
        let bottomEndMinutes = TOMORROW_NIGHT_MINUTES;
        // Top timeline: user's fine range selection (boundaries are bottomStart to bottomEnd)
        let topStartMinutes = LAST_WEEK_MINUTES;
        let topEndMinutes = TOMORROW_NIGHT_MINUTES;

        let viewStartMinutes = LAST_WEEK_MINUTES;
        let viewEndMinutes = TOMORROW_NIGHT_MINUTES;
        let currentViewMinutes = 0; // Current position shown on the timeline
        
        // Track manual fine granularity override (null means auto-calculate)
        let manualFineGranularity = null;

        function getGranularityIndex(granularity) {
            const granularities = Object.keys(GRANULARITY_TO_MINUTES);
            return granularities.indexOf(granularity);
        }

        function getGranularityTwoLevelsLess(granularity) {
            const granularities = Object.keys(GRANULARITY_TO_MINUTES);
            const currentIndex = getGranularityIndex(granularity);
            const targetIndex = Math.min(currentIndex + 2, granularities.length - 1);
            return granularities[targetIndex];
        }
        
        // Get the current fine granularity (manual override or auto-calculated)
        function getCurrentFineGranularity() {
            if (manualFineGranularity) {
                return manualFineGranularity;
            }
            const bottomSpan = bottomEndMinutes - bottomStartMinutes;
            return calculateFineGranularity(bottomSpan);
        }

        // Calculate appropriate fine granularity based on the span of the bottom slider's range
        // The goal is to find a granularity such that the fine slider takes up approximately
        // 1/4 of the track width while providing smooth navigation
        function calculateFineGranularity(spanMinutes) {
            const granularities = Object.keys(GRANULARITY_TO_MINUTES);
            const granularityValues = Object.values(GRANULARITY_TO_MINUTES);
            
            // Target: fine slider should span about 1/4 of the bottom slider's range
            // This means we want a granularity where 10-40 units fit in 1/4 of the span
            const targetSpan = spanMinutes / 4;
            
            // Find the COARSEST granularity where we have at least 10 units in the target span
            // Start from coarsest and work toward finer
            for (let i = 0; i < granularities.length; i++) {
                const unitMinutes = granularityValues[i];
                const numUnitsInQuarter = targetSpan / unitMinutes;
                
                // We want at least 10 units to provide smooth sliding
                if (numUnitsInQuarter >= 10) {
                    return granularities[i];
                }
            }
            
            // If even the finest granularity doesn't give us 10 units, use it anyway
            return granularities[granularities.length - 1];
        }

        function initializeTimelines() {
            // Bottom timeline (coarse selector) is already set to LAST_WEEK to TOMORROW_NIGHT
            // Just need to set the top timeline to fit within it
            
            // Set top timeline to take up a portion of bottom range width
            const topMidpoint = (bottomStartMinutes + bottomEndMinutes) / 2;
            const topHalfSpan = (bottomEndMinutes - bottomStartMinutes) / 8; // 1/8 to get 1/4 total
            topStartMinutes = topMidpoint - topHalfSpan;
            topEndMinutes = topMidpoint + topHalfSpan;
            
            // Set view to show the top timeline's range
            currentViewMinutes = topMidpoint;
        }

        function clampMinutes(value) {
            return Math.min(Math.max(value, TIMELINE_MIN), TIMELINE_MAX);
        }

        // Convert date components to minutes from center
        function dateComponentsToMinutes(era, year, month, day, hour, minute) {
            const eraSign = parseInt(era);
            const y = parseInt(year) || 1;
            const m = parseInt(month) || 1;
            const d = parseInt(day) || 1;
            const h = parseInt(hour) || 0;
            const min = parseInt(minute) || 0;
            
            // Calculate total minutes from year 1 CE (which is at 0 minutes)
            let totalMinutes = 0;
            
            if (eraSign === 1) {
                // CE: Year 1 CE starts at 0, Year 2 CE starts at MINUTES_PER_YEAR, etc.
                totalMinutes = (y - 1) * MINUTES_PER_YEAR;
                totalMinutes += (m - 1) * MINUTES_PER_MONTH;
                totalMinutes += (d - 1) * MINUTES_PER_DAY;
                totalMinutes += h * MINUTES_PER_HOUR;
                totalMinutes += min;
            } else {
                // BCE: Year 1 BCE starts at -MINUTES_PER_YEAR, Year 2 BCE starts at -2*MINUTES_PER_YEAR, etc.
                // Within each year, months/days/hours/minutes add forward (Jan=left, Dec=right)
                totalMinutes = -(y * MINUTES_PER_YEAR);
                totalMinutes += (m - 1) * MINUTES_PER_MONTH;
                totalMinutes += (d - 1) * MINUTES_PER_DAY;
                totalMinutes += h * MINUTES_PER_HOUR;
                totalMinutes += min;
            }
            
            return totalMinutes;
        }

        // Convert minutes from center to date components
        function minutesToDateComponents(minutes) {
            if (minutes >= 0) {
                // CE: straightforward calculation
                let remaining = minutes;
                const years = Math.floor(remaining / MINUTES_PER_YEAR);
                remaining -= years * MINUTES_PER_YEAR;
                
                const months = Math.floor(remaining / MINUTES_PER_MONTH);
                remaining -= months * MINUTES_PER_MONTH;
                
                const days = Math.floor(remaining / MINUTES_PER_DAY);
                remaining -= days * MINUTES_PER_DAY;
                
                const hours = Math.floor(remaining / MINUTES_PER_HOUR);
                remaining -= hours * MINUTES_PER_HOUR;
                
                const mins = Math.floor(remaining);
                
                return {
                    era: 1,
                    year: years + 1,
                    month: months + 1,
                    day: days + 1,
                    hour: hours,
                    minute: mins
                };
            } else {
                // BCE: Year N BCE spans from -(N*MINUTES_PER_YEAR) to -((N-1)*MINUTES_PER_YEAR)
                const absMinutes = Math.abs(minutes);
                const years = Math.ceil(absMinutes / MINUTES_PER_YEAR);
                
                // Calculate the start of this year (most negative point)
                const yearStart = -(years * MINUTES_PER_YEAR);
                
                // Calculate offset from year start (positive for sub-year components)
                const offsetFromYearStart = minutes - yearStart;
                
                let remaining = offsetFromYearStart;
                const months = Math.floor(remaining / MINUTES_PER_MONTH);
                remaining -= months * MINUTES_PER_MONTH;
                
                const days = Math.floor(remaining / MINUTES_PER_DAY);
                remaining -= days * MINUTES_PER_DAY;
                
                const hours = Math.floor(remaining / MINUTES_PER_HOUR);
                remaining -= hours * MINUTES_PER_HOUR;
                
                const mins = Math.floor(remaining);
                
                return {
                    era: -1,
                    year: years,
                    month: months + 1,
                    day: days + 1,
                    hour: hours,
                    minute: mins
                };
            }
        }

        // Update the date component inputs based on current viewStartMinutes and viewEndMinutes
        function updateDateInputs() {
            const startComponents = minutesToDateComponents(viewStartMinutes);
            startEra.value = startComponents.era;
            startYearComp.value = startComponents.year;
            startMonth.value = startComponents.month;
            startDay.value = startComponents.day;
            startHour.value = startComponents.hour;
            startMinute.value = startComponents.minute;
            
            const endComponents = minutesToDateComponents(viewEndMinutes);
            endEra.value = endComponents.era;
            endYearComp.value = endComponents.year;
            endMonth.value = endComponents.month;
            endDay.value = endComponents.day;
            endHour.value = endComponents.hour;
            endMinute.value = endComponents.minute;
        }

        // Geologic period visualization functions
        const topGeologicSegments = document.getElementById('topGeologicSegments');
        const bottomGeologicSegments = document.getElementById('bottomGeologicSegments');
        const geologicTooltip = document.getElementById('geologicTooltip');
        const tooltipHeader = document.getElementById('tooltipHeader');
        const tooltipEon = document.getElementById('tooltipEon');
        const tooltipEra = document.getElementById('tooltipEra');
        const tooltipPeriod = document.getElementById('tooltipPeriod');
        const tooltipEpoch = document.getElementById('tooltipEpoch');
        const tooltipDates = document.getElementById('tooltipDates');

        function renderGeologicSegments(container, rangeStartMinutes, rangeEndMinutes) {
            // Clear existing segments
            container.innerHTML = '';
            
            // Helper function to get the actual end time for a period (extends Holocene to present)
            const getPeriodEnd = (period) => (period.endMya === 0) ? CURRENT_DATE_MINUTES : period.endMinutes;
            
            // Find all periods that overlap with the visible range
            const visiblePeriods = GEOLOGIC_PERIODS.filter(period => {
                const periodEnd = getPeriodEnd(period);
                return periodEnd >= rangeStartMinutes && period.startMinutes <= rangeEndMinutes;
            });
            
            const totalRange = rangeEndMinutes - rangeStartMinutes;
            
            visiblePeriods.forEach(period => {
                const periodEnd = getPeriodEnd(period);
                
                // Calculate the visible portion of this period
                const segmentStart = Math.max(period.startMinutes, rangeStartMinutes);
                const segmentEnd = Math.min(periodEnd, rangeEndMinutes);
                
                // Calculate position as percentage
                const leftPercent = ((segmentStart - rangeStartMinutes) / totalRange) * 100;
                const widthPercent = ((segmentEnd - segmentStart) / totalRange) * 100;
                
                // Skip if the segment is too small to see (< 0.1%)
                if (widthPercent < 0.1) {
                    return;
                }
                
                // Create segment element
                const segment = document.createElement('div');
                segment.className = 'geologic-segment';
                segment.style.left = `${leftPercent}%`;
                segment.style.width = `${widthPercent}%`;
                segment.style.backgroundColor = period.color;
                
                // Add hover tooltip
                segment.addEventListener('mouseenter', (e) => {
                    showGeologicTooltip(period, e);
                });
                
                segment.addEventListener('mousemove', (e) => {
                    updateTooltipPosition(e);
                });
                
                segment.addEventListener('mouseleave', () => {
                    hideGeologicTooltip();
                });
                
                container.appendChild(segment);
            });
            
            // Add future segment if range extends into the future
            if (rangeEndMinutes > CURRENT_DATE_MINUTES && rangeStartMinutes < TIMELINE_MAX) {
                const futureStart = Math.max(CURRENT_DATE_MINUTES, rangeStartMinutes);
                const futureEnd = Math.min(TIMELINE_MAX, rangeEndMinutes);
                
                const leftPercent = ((futureStart - rangeStartMinutes) / totalRange) * 100;
                const widthPercent = ((futureEnd - futureStart) / totalRange) * 100;
                
                // Only render if visible (> 0.1%)
                if (widthPercent >= 0.1) {
                    const futureSegment = document.createElement('div');
                    futureSegment.className = 'geologic-segment';
                    futureSegment.style.left = `${leftPercent}%`;
                    futureSegment.style.width = `${widthPercent}%`;
                    futureSegment.style.backgroundColor = 'rgba(168, 85, 247, 0.3)'; // Purple for future
                    
                    // Add hover tooltip for future
                    futureSegment.addEventListener('mouseenter', (e) => {
                        showFutureTooltip(e);
                    });
                    
                    futureSegment.addEventListener('mousemove', (e) => {
                        updateTooltipPosition(e);
                    });
                    
                    futureSegment.addEventListener('mouseleave', () => {
                        hideGeologicTooltip();
                    });
                    
                    container.appendChild(futureSegment);
                }
            }
        }

        function showGeologicTooltip(period, event) {
            tooltipHeader.textContent = period.epoch;
            tooltipHeader.style.borderBottomColor = period.color;
            tooltipEon.textContent = period.eon;
            tooltipEra.textContent = period.era;
            tooltipPeriod.textContent = period.period;
            tooltipEpoch.textContent = period.epoch;
            
            // Format dates
            const startMya = period.startMya;
            const endMya = period.endMya;
            let dateText;
            if (endMya === 0) {
                dateText = `${startMya.toFixed(2)} Ma - Present`;
            } else {
                dateText = `${startMya.toFixed(2)} - ${endMya.toFixed(2)} Ma`;
            }
            tooltipDates.textContent = dateText;
            
            geologicTooltip.classList.add('visible');
            updateTooltipPosition(event);
        }

        function showFutureTooltip(event) {
            tooltipHeader.textContent = 'Future';
            tooltipHeader.style.borderBottomColor = 'rgba(168, 85, 247, 0.8)';
            tooltipEon.textContent = '—';
            tooltipEra.textContent = '—';
            tooltipPeriod.textContent = '—';
            tooltipEpoch.textContent = 'Future';
            tooltipDates.textContent = 'Present onward';
            
            geologicTooltip.classList.add('visible');
            updateTooltipPosition(event);
        }

        function updateTooltipPosition(event) {
            const tooltipRect = geologicTooltip.getBoundingClientRect();
            const offset = 15;
            
            // Get the bounds of the dual-timeline-container
            const timelineContainer = document.querySelector('.dual-timeline-container');
            const containerRect = timelineContainer.getBoundingClientRect();
            
            let left = event.clientX + offset;
            let top = event.clientY + offset;
            
            // Constrain horizontally within the timeline container
            if (left + tooltipRect.width > containerRect.right) {
                left = event.clientX - tooltipRect.width - offset;
            }
            if (left < containerRect.left) {
                left = containerRect.left + offset;
            }
            
            // Constrain vertically within the timeline container
            if (top + tooltipRect.height > containerRect.bottom) {
                top = event.clientY - tooltipRect.height - offset;
            }
            if (top < containerRect.top) {
                top = containerRect.top + offset;
            }
            
            geologicTooltip.style.left = `${left}px`;
            geologicTooltip.style.top = `${top}px`;
        }

        function hideGeologicTooltip() {
            geologicTooltip.classList.remove('visible');
        }

        function updateViewRange() {
            // Get start date components
            let startMinutes = dateComponentsToMinutes(
                startEra.value,
                startYearComp.value,
                startMonth.value,
                startDay.value,
                startHour.value,
                startMinute.value
            );
            
            // Get end date components
            let endMinutes = dateComponentsToMinutes(
                endEra.value,
                endYearComp.value,
                endMonth.value,
                endDay.value,
                endHour.value,
                endMinute.value
            );
            
            startMinutes = clampMinutes(startMinutes);
            endMinutes = clampMinutes(endMinutes);

            if (startMinutes === endMinutes) {
                // Use a reasonable default minimum span (1 day)
                const minimumSpan = 1440; // 1 day in minutes
                if (endMinutes >= TIMELINE_MAX) {
                    startMinutes = Math.max(TIMELINE_MIN, endMinutes - minimumSpan);
                }
                endMinutes = Math.min(startMinutes + minimumSpan, TIMELINE_MAX);
            }

            if (startMinutes > endMinutes) {
                [startMinutes, endMinutes] = [endMinutes, startMinutes];
            }

            viewStartMinutes = startMinutes;
            viewEndMinutes = endMinutes;

            updateDateInputs();

            // Date inputs define the boundaries for the bottom slider
            // Initialize bottom slider to a reasonable position within these boundaries
            const viewSpan = viewEndMinutes - viewStartMinutes;
            const midpoint = (viewStartMinutes + viewEndMinutes) / 2;
            
            // Set bottom slider range to middle portion of view boundaries
            // Try to keep existing bottom range if it fits, otherwise reinitialize
            if (bottomStartMinutes < viewStartMinutes || bottomEndMinutes > viewEndMinutes) {
                // Bottom range is outside new boundaries, reinitialize
                const quarterSpan = viewSpan / 4;
                bottomStartMinutes = midpoint - quarterSpan;
                bottomEndMinutes = midpoint + quarterSpan;
            }
            
            // Ensure bottom timeline has minimum span to allow grabbing the range bar
            // Use pixel-based minimum: the time span equivalent to 50 pixels on the slider track
            const wrapperWidth = bottomSliderWrapper.getBoundingClientRect().width;
            const minPixelSpan = calculateMinPixelSpan(wrapperWidth, viewSpan);
            if (bottomEndMinutes - bottomStartMinutes < minPixelSpan) {
                bottomEndMinutes = Math.min(viewEndMinutes, bottomStartMinutes + minPixelSpan);
                if (bottomEndMinutes - bottomStartMinutes < minPixelSpan) {
                    bottomStartMinutes = Math.max(viewStartMinutes, bottomEndMinutes - minPixelSpan);
                }
            }
            
            // Update top timeline to be centered within bottom range
            const bottomSpan = bottomEndMinutes - bottomStartMinutes;
            const fineGranularity = getCurrentFineGranularity();
            const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
            
            // Try to keep existing top range if it fits
            if (topStartMinutes < bottomStartMinutes || topEndMinutes > bottomEndMinutes) {
                // Top range is outside new bottom boundaries, reinitialize
                const bottomMidpoint = (bottomStartMinutes + bottomEndMinutes) / 2;
                // Target: 1/4 of bottom span, but at least 10 units of the fine granularity
                const targetTopSpan = Math.max(bottomSpan / 4, minTopSpan * 10);
                const topHalfSpan = targetTopSpan / 2;
                topStartMinutes = bottomMidpoint - topHalfSpan;
                topEndMinutes = bottomMidpoint + topHalfSpan;
            }
            
            // Ensure top timeline has minimum span (at least 10 granularity units)
            const minAllowedTopSpan = minTopSpan * 10;
            if (topEndMinutes - topStartMinutes < minAllowedTopSpan) {
                const currentMidpoint = (topStartMinutes + topEndMinutes) / 2;
                const halfSpan = minAllowedTopSpan / 2;
                topStartMinutes = Math.max(bottomStartMinutes, currentMidpoint - halfSpan);
                topEndMinutes = Math.min(bottomEndMinutes, currentMidpoint + halfSpan);
                // Adjust if we hit boundaries
                if (topEndMinutes - topStartMinutes < minAllowedTopSpan) {
                    topEndMinutes = Math.min(bottomEndMinutes, topStartMinutes + minAllowedTopSpan);
                    if (topEndMinutes - topStartMinutes < minAllowedTopSpan) {
                        topStartMinutes = Math.max(bottomStartMinutes, topEndMinutes - minAllowedTopSpan);
                    }
                }
            }
            
            updateRangeSliders();
            // Update the main view display to show the top timeline's range
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        function refreshRangeDisplay() {
            // Display the top timeline's current range with full date/time details
            const startComponents = minutesToDateComponents(topStartMinutes);
            const endComponents = minutesToDateComponents(topEndMinutes);
            
            const startEra = startComponents.era === 1 ? "CE" : "BCE";
            const endEra = endComponents.era === 1 ? "CE" : "BCE";
            
            const startMonthIndex = Math.min(Math.max(startComponents.month - 1, 0), 11);
            const endMonthIndex = Math.min(Math.max(endComponents.month - 1, 0), 11);
            
            const startLabel = `${MONTH_NAMES[startMonthIndex]} ${startComponents.day}, ${formatYear(startComponents.year)} ${pad(startComponents.hour)}:${pad(startComponents.minute)} ${startEra}`;
            const endLabel = `${MONTH_NAMES[endMonthIndex]} ${endComponents.day}, ${formatYear(endComponents.year)} ${pad(endComponents.hour)}:${pad(endComponents.minute)} ${endEra}`;
            
            rangeDisplay.innerHTML = `<strong>${startLabel}</strong> to <strong>${endLabel}</strong>`;
        }

        function rebuildTicks() {
            // Removed - no longer displaying timeline ticks
        }

        function formatSliderLabel(minutes, granularity) {
            if (Math.abs(minutes) < 0.5) {
                return "Center";
            }
            
            const components = minutesToDateComponents(minutes);
            const era = components.era === 1 ? "CE" : "BCE";
            const monthIndex = Math.min(Math.max(components.month - 1, 0), 11);
            
            // Format at the same granularity level as selected
            if (granularity === "Eon") {
                // Show in billions of years for Eon scale
                const eonYears = Math.round(components.year / 1_000_000_000);
                return `${compactFormatter.format(eonYears)} B yrs ${era}`;
            } else if (granularity === "Epoch") {
                // Show in millions of years for Epoch scale
                const epochYears = Math.round(components.year / 1_000_000);
                return `${compactFormatter.format(epochYears)} M yrs ${era}`;
            } else if (granularity === "Age") {
                // Show in thousands of years for Age scale
                const ageYears = Math.round(components.year / 1000);
                return `${compactFormatter.format(ageYears)}K yrs ${era}`;
            } else if (granularity === "Millennium") {
                // Show specific year for Millennium
                return `Year ${compactFormatter.format(components.year)} ${era}`;
            } else if (granularity === "Century") {
                // Show specific year for Century
                return `Year ${compactFormatter.format(components.year)} ${era}`;
            } else if (granularity === "Decade") {
                // Show specific year for Decade
                return `Year ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Year") {
                // Show specific year
                return `Year ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Month") {
                // Show Month and Year
                return `${MONTH_NAMES[monthIndex]} ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Week") {
                // Show Week (calculate from day of year using components)
                // components.month and components.day already account for BCE calendar order
                const dayOfYear = (components.month - 1) * 30 + (components.day - 1);
                const weekNum = Math.floor(dayOfYear / 7) + 1;
                return `Week ${weekNum}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Day") {
                // Show Month, Day, and Year
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Hour") {
                // Show Day and Time with Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${pad(components.hour)}:00 ${era}`;
            } else if (granularity === "Minute") {
                // Show Time with minutes and Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${pad(components.hour)}:${pad(components.minute)} ${era}`;
            }
            
            // Fallback
            return formatYearLabel(minutes);
        }

        function updatePointerAndDetails() {
            // Removed - no longer displaying pointer and details
        }

        function formatYearLabel(minutes) {
            if (minutes === 0) {
                return "Year 1 CE";
            }
            
            const components = minutesToDateComponents(minutes);
            const label = compactFormatter.format(components.year);
            const era = components.era === 1 ? "CE" : "BCE";
            return `Year ${label} ${era}`;
        }

        function formatTickLabel(minutes) {
            if (minutes === 0) {
                return "Center";
            }
            
            // Use the fine granularity for tick labels
            const granularity = getCurrentFineGranularity();
            
            // For large time scales (Eon, Epoch, Age, Millennium, Century, Decade, Year), use year-based format
            if (granularity === "Eon" || granularity === "Epoch" || granularity === "Age" || 
                granularity === "Millennium" || granularity === "Century" || granularity === "Decade" || 
                granularity === "Year") {
                return formatYearLabel(minutes);
            }
            
            // For sub-year granularities, use minutesToDateComponents to get correct date
            const components = minutesToDateComponents(minutes);
            const era = components.era === 1 ? "CE" : "BCE";
            const monthIndex = Math.min(Math.max(components.month - 1, 0), 11);
            
            // Format based on granularity
            if (granularity === "Month") {
                // Show Month and Year
                return `${MONTH_NAMES[monthIndex]} ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Week" || granularity === "Day") {
                // Show Month, Day, and Year
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Hour") {
                // Show Day and Time with Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:00 ${era}`;
            } else {
                // Minute
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:${pad(components.minute)} ${era}`;
            }
        }

        function formatDetailedTime(minutes, granularity) {
            if (minutes === 0) {
                return "Center (Year 1 CE · Month 1 · Day 1 · 00:00)";
            }
            
            const components = minutesToDateComponents(minutes);
            const era = components.era === 1 ? "CE" : "BCE";
            const monthIndex = Math.min(Math.max(components.month - 1, 0), 11);
            
            // Format based on granularity
            if (granularity === "Eon" || granularity === "Epoch" || granularity === "Age" || 
                granularity === "Millennium" || granularity === "Century" || granularity === "Decade") {
                // For very large scales, show year with compact notation
                const yearLabel = compactFormatter.format(components.year);
                return `Year ${yearLabel} ${era}`;
            } else if (granularity === "Year") {
                // Show full year
                return `Year ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Month") {
                // Show Month and Year
                return `${MONTH_NAMES[monthIndex]} ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Week" || granularity === "Day") {
                // Show Month, Day, and Year
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Hour") {
                // Show Day and Time with Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:00 ${era}`;
            } else if (granularity === "Minute") {
                // Show Time with minutes and Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:${pad(components.minute)} ${era}`;
            }

            // Fallback to detailed format
            return `Year ${formatYear(components.year)} ${era} · Month ${components.month} · Day ${components.day} · ${pad(components.hour)}:${pad(components.minute)}`;
        }

        function formatDifference(minutes, granularity) {
            if (minutes === 0) {
                return "Exactly at the center moment.";
            }
            const unitMinutes = GRANULARITY_TO_MINUTES[granularity];
            const diffUnits = minutes / unitMinutes;
            const direction = minutes >= 0 ? "after" : "before";
            const absoluteUnits = Math.abs(diffUnits);
            const formattedUnits = absoluteUnits >= 1000
                ? numberFormatter.format(Math.round(absoluteUnits))
                : absoluteUnits.toFixed(2);
            const unitLabel = getUnitLabel(granularity, Math.abs(absoluteUnits - 1) >= 1e-6, false);
            return `${formattedUnits} ${unitLabel} ${direction} the center moment.`;
        }

        function getUnitLabel(granularity, isPlural, capitalize) {
            const entry = UNIT_LABELS[granularity];
            if (!entry) {
                return granularity;
            }
            const text = isPlural ? entry.plural : entry.singular;
            return capitalize ? text.charAt(0).toUpperCase() + text.slice(1) : text;
        }

        function formatYearInputValue(minutes) {
            const years = minutes / MINUTES_PER_YEAR;
            const rounded = Math.round(years * 1000) / 1000;
            const sanitized = Math.abs(rounded) < 1e-6 ? 0 : rounded;
            return sanitized.toString();
        }

        function pad(value) {
            return value.toString().padStart(2, "0");
        }

        // Calculate minimum span in minutes to allow grabbing the range between handles
        function calculateMinPixelSpan(wrapperWidth, totalRange) {
            const minPixels = 50; // Minimum pixel separation to allow grabbing the range bar
            const effectiveWidth = wrapperWidth - 24; // Account for padding
            return (minPixels / effectiveWidth) * totalRange;
        }

        // Apply two-tone gradient to track based on current date position
        function applyTwoToneGradient(element, startMinutes, endMinutes, isWrapper = false, isMainTrack = false) {
            const totalRange = endMinutes - startMinutes;
            
            // If current date is outside the range, use single color
            if (CURRENT_DATE_MINUTES <= startMinutes) {
                // Entire range is in the future
                if (isWrapper) {
                    element.style.background = 'linear-gradient(90deg, rgba(168, 85, 247, 0.15), rgba(126, 34, 206, 0.15))';
                } else if (isMainTrack) {
                    element.style.background = 'linear-gradient(90deg, rgba(168, 85, 247, 0.3), rgba(126, 34, 206, 0.6), rgba(168, 85, 247, 0.3))';
                    element.style.boxShadow = 'inset 0 0 12px rgba(168, 85, 247, 0.35)';
                } else {
                    element.style.background = 'rgba(168, 85, 247, 0.3)';
                }
            } else if (CURRENT_DATE_MINUTES >= endMinutes) {
                // Entire range is in the past
                if (isWrapper) {
                    element.style.background = 'linear-gradient(90deg, rgba(14, 165, 233, 0.15), rgba(37, 99, 235, 0.15))';
                } else if (isMainTrack) {
                    element.style.background = 'linear-gradient(90deg, rgba(14, 165, 233, 0.3), rgba(2, 132, 199, 0.6), rgba(14, 165, 233, 0.3))';
                    element.style.boxShadow = 'inset 0 0 12px rgba(14, 165, 233, 0.35)';
                } else {
                    element.style.background = 'rgba(148, 163, 184, 0.3)';
                }
            } else {
                // Current date falls within the range - create split gradient
                const currentPercent = ((CURRENT_DATE_MINUTES - startMinutes) / totalRange) * 100;
                
                if (isWrapper) {
                    element.style.background = `linear-gradient(90deg, 
                        rgba(14, 165, 233, 0.15) 0%, 
                        rgba(37, 99, 235, 0.15) ${currentPercent}%, 
                        rgba(168, 85, 247, 0.15) ${currentPercent}%, 
                        rgba(126, 34, 206, 0.15) 100%)`;
                } else if (isMainTrack) {
                    element.style.background = `linear-gradient(90deg, 
                        rgba(14, 165, 233, 0.3) 0%,
                        rgba(2, 132, 199, 0.6) ${currentPercent / 2}%,
                        rgba(14, 165, 233, 0.3) ${currentPercent}%,
                        rgba(168, 85, 247, 0.3) ${currentPercent}%,
                        rgba(126, 34, 206, 0.6) ${(100 + currentPercent) / 2}%,
                        rgba(168, 85, 247, 0.3) 100%)`;
                    element.style.boxShadow = 'inset 0 0 12px rgba(14, 165, 233, 0.2), inset 0 0 12px rgba(168, 85, 247, 0.2)';
                } else {
                    element.style.background = `linear-gradient(90deg, 
                        rgba(148, 163, 184, 0.3) 0%, 
                        rgba(148, 163, 184, 0.3) ${currentPercent}%, 
                        rgba(168, 85, 247, 0.3) ${currentPercent}%, 
                        rgba(168, 85, 247, 0.3) 100%)`;
                }
            }
        }

        // Apply two-tone gradient to selected range bar based on current date position
        function applySelectedRangeGradient(element, rangeStartMinutes, rangeEndMinutes, viewStartMinutes, viewEndMinutes) {
            // If range doesn't span the current date, use simple gradient
            if (CURRENT_DATE_MINUTES <= rangeStartMinutes) {
                // Entire range is in the future
                element.style.background = 'linear-gradient(90deg, var(--future-accent), var(--future-accent-dark))';
            } else if (CURRENT_DATE_MINUTES >= rangeEndMinutes) {
                // Entire range is in the past
                element.style.background = 'linear-gradient(90deg, var(--accent), var(--accent-dark))';
            } else {
                // Range spans the current date - calculate gradient position to match background
                // The background transitions at a certain percentage within the view range
                const viewRange = viewEndMinutes - viewStartMinutes;
                const currentPercentInView = ((CURRENT_DATE_MINUTES - viewStartMinutes) / viewRange) * 100;
                
                // The selected bar is positioned within the view
                const selectedStartPercent = ((rangeStartMinutes - viewStartMinutes) / viewRange) * 100;
                const selectedEndPercent = ((rangeEndMinutes - viewStartMinutes) / viewRange) * 100;
                const selectedWidth = selectedEndPercent - selectedStartPercent;
                
                // Calculate where the transition should appear within the selected bar
                // to align with the background transition
                const transitionPercentWithinBar = ((currentPercentInView - selectedStartPercent) / selectedWidth) * 100;
                
                element.style.background = `linear-gradient(90deg, 
                    var(--accent) 0%, 
                    var(--accent-dark) ${transitionPercentWithinBar}%, 
                    var(--future-accent) ${transitionPercentWithinBar}%, 
                    var(--future-accent-dark) 100%)`;
            }
        }

        // Range slider functionality
        function updateRangeSliders() {
            updateBottomSlider();
            updateTopSlider();
        }

        function updateBottomSlider() {
            // Bottom slider boundaries are set by the date inputs (viewStartMinutes and viewEndMinutes)
            const totalRange = viewEndMinutes - viewStartMinutes;
            
            // Prevent division by zero
            if (totalRange === 0) {
                bottomStartHandle.style.left = '50%';
                bottomEndHandle.style.left = '50%';
                bottomSelected.style.left = '50%';
                bottomSelected.style.width = '0%';
                return;
            }
            
            const startPercent = ((bottomStartMinutes - viewStartMinutes) / totalRange) * 100;
            const endPercent = ((bottomEndMinutes - viewStartMinutes) / totalRange) * 100;
            
            bottomStartHandle.style.left = `${startPercent}%`;
            bottomEndHandle.style.left = `${endPercent}%`;
            bottomSelected.style.left = `${startPercent}%`;
            bottomSelected.style.width = `${endPercent - startPercent}%`;
            
            // Apply gradient to selected range based on whether it spans the current date
            applySelectedRangeGradient(bottomSelected, bottomStartMinutes, bottomEndMinutes, viewStartMinutes, viewEndMinutes);
            
            // Apply future styling to handles if the range end is in the future
            if (bottomEndMinutes > CURRENT_DATE_MINUTES) {
                bottomStartHandle.classList.add('future');
                bottomEndHandle.classList.add('future');
            } else {
                bottomStartHandle.classList.remove('future');
                bottomEndHandle.classList.remove('future');
            }
            
            // Apply two-tone gradient to track and wrapper
            applyTwoToneGradient(bottomSliderTrack, viewStartMinutes, viewEndMinutes, false);
            applyTwoToneGradient(bottomSliderWrapper, viewStartMinutes, viewEndMinutes, true);
            
            // Render geologic segments
            renderGeologicSegments(bottomGeologicSegments, viewStartMinutes, viewEndMinutes);
        }

        function updateTopSlider() {
            const totalRange = bottomEndMinutes - bottomStartMinutes;
            
            // Prevent division by zero
            if (totalRange === 0) {
                topStartHandle.style.left = '50%';
                topEndHandle.style.left = '50%';
                topSelected.style.left = '50%';
                topSelected.style.width = '0%';
                return;
            }
            
            const startPercent = ((topStartMinutes - bottomStartMinutes) / totalRange) * 100;
            const endPercent = ((topEndMinutes - bottomStartMinutes) / totalRange) * 100;
            
            topStartHandle.style.left = `${startPercent}%`;
            topEndHandle.style.left = `${endPercent}%`;
            topSelected.style.left = `${startPercent}%`;
            topSelected.style.width = `${endPercent - startPercent}%`;
            
            // Apply gradient to selected range based on whether it spans the current date
            applySelectedRangeGradient(topSelected, topStartMinutes, topEndMinutes, bottomStartMinutes, bottomEndMinutes);
            
            // Apply future styling to handles if the range end is in the future
            if (topEndMinutes > CURRENT_DATE_MINUTES) {
                topStartHandle.classList.add('future');
                topEndHandle.classList.add('future');
            } else {
                topStartHandle.classList.remove('future');
                topEndHandle.classList.remove('future');
            }
            
            // Apply two-tone gradient to track and wrapper
            applyTwoToneGradient(topSliderTrack, bottomStartMinutes, bottomEndMinutes, false);
            applyTwoToneGradient(topSliderWrapper, bottomStartMinutes, bottomEndMinutes, true);
            
            // Render geologic segments
            renderGeologicSegments(topGeologicSegments, bottomStartMinutes, bottomEndMinutes);
        }

        // Drag handling for bottom timeline
        let dragState = null;

        function startBottomDrag(type, event) {
            event.preventDefault();
            const rect = bottomSliderWrapper.getBoundingClientRect();
            // Bottom slider boundaries are set by the date inputs
            const totalRange = viewEndMinutes - viewStartMinutes;
            
            dragState = {
                type: type,
                timeline: 'bottom',
                startX: event.clientX,
                startMinutesStart: bottomStartMinutes,
                startMinutesEnd: bottomEndMinutes,
                wrapperRect: rect,
                totalRange: totalRange,
                boundaryMin: viewStartMinutes,
                boundaryMax: viewEndMinutes
            };
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', endDrag);
        }

        function startTopDrag(type, event) {
            event.preventDefault();
            const rect = topSliderWrapper.getBoundingClientRect();
            const totalRange = bottomEndMinutes - bottomStartMinutes;
            
            dragState = {
                type: type,
                timeline: 'top',
                startX: event.clientX,
                startMinutesStart: topStartMinutes,
                startMinutesEnd: topEndMinutes,
                wrapperRect: rect,
                totalRange: totalRange
            };
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', endDrag);
        }

        function handleDrag(event) {
            if (!dragState) return;
            
            const deltaX = event.clientX - dragState.startX;
            const wrapperWidth = dragState.wrapperRect.width - 24; // Account for padding
            const deltaPercent = deltaX / wrapperWidth;
            const deltaMinutes = deltaPercent * dragState.totalRange;
            
            if (dragState.timeline === 'bottom') {
                handleBottomDrag(deltaMinutes);
            } else {
                handleTopDrag(deltaMinutes);
            }
        }

        function handleBottomDrag(deltaMinutes) {
            const boundaryMin = dragState.boundaryMin || viewStartMinutes;
            const boundaryMax = dragState.boundaryMax || viewEndMinutes;
            
            // Calculate minimum span based on 50px minimum separation to allow grabbing the range bar
            const minPixelSpan = calculateMinPixelSpan(dragState.wrapperRect.width, dragState.totalRange);
            
            // Use only the pixel-based minimum (no hardcoded time-based minimum)
            const effectiveMinSpan = minPixelSpan;
            
            if (dragState.type === 'start') {
                let newStart = dragState.startMinutesStart + deltaMinutes;
                // Constrain within date input boundaries
                newStart = Math.max(boundaryMin, Math.min(newStart, bottomEndMinutes - effectiveMinSpan));
                newStart = Math.max(boundaryMin, newStart); // Ensure it doesn't go below min
                bottomStartMinutes = newStart;
                
                // If start moved, ensure end respects boundaries too
                if (bottomEndMinutes > boundaryMax) {
                    bottomEndMinutes = boundaryMax;
                }
                if (bottomEndMinutes - bottomStartMinutes < effectiveMinSpan) {
                    bottomEndMinutes = Math.min(boundaryMax, bottomStartMinutes + effectiveMinSpan);
                }
                
                // Constrain top timeline within new bottom bounds
                const bottomSpan = bottomEndMinutes - bottomStartMinutes;
                const fineGranularity = getCurrentFineGranularity();
                const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
                topStartMinutes = Math.max(bottomStartMinutes, Math.min(topStartMinutes, bottomEndMinutes - minTopSpan));
                topEndMinutes = Math.min(bottomEndMinutes, Math.max(topEndMinutes, topStartMinutes + minTopSpan));
            } else if (dragState.type === 'end') {
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                // Constrain within date input boundaries
                newEnd = Math.min(boundaryMax, Math.max(newEnd, bottomStartMinutes + effectiveMinSpan));
                newEnd = Math.min(boundaryMax, newEnd); // Ensure it doesn't go above max
                bottomEndMinutes = newEnd;
                
                // If end moved, ensure start respects boundaries too
                if (bottomStartMinutes < boundaryMin) {
                    bottomStartMinutes = boundaryMin;
                }
                if (bottomEndMinutes - bottomStartMinutes < effectiveMinSpan) {
                    bottomStartMinutes = Math.max(boundaryMin, bottomEndMinutes - effectiveMinSpan);
                }
                
                // Constrain top timeline within new bottom bounds
                const bottomSpan = bottomEndMinutes - bottomStartMinutes;
                const fineGranularity = getCurrentFineGranularity();
                const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
                topStartMinutes = Math.max(bottomStartMinutes, Math.min(topStartMinutes, bottomEndMinutes - minTopSpan));
                topEndMinutes = Math.min(bottomEndMinutes, Math.max(topEndMinutes, topStartMinutes + minTopSpan));
            } else if (dragState.type === 'range') {
                const span = dragState.startMinutesEnd - dragState.startMinutesStart;
                
                // Prevent division by zero
                if (span === 0) {
                    return;
                }
                
                let newStart = dragState.startMinutesStart + deltaMinutes;
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                
                // Keep within date input boundaries
                if (newStart < boundaryMin) {
                    newStart = boundaryMin;
                    newEnd = newStart + span;
                }
                if (newEnd > boundaryMax) {
                    newEnd = boundaryMax;
                    newStart = newEnd - span;
                }
                
                // Double-check both are within bounds
                newStart = Math.max(boundaryMin, Math.min(newStart, boundaryMax - span));
                newEnd = Math.min(boundaryMax, Math.max(newEnd, boundaryMin + span));
                
                bottomStartMinutes = newStart;
                bottomEndMinutes = newEnd;
                
                // Move top timeline proportionally
                const topSpan = topEndMinutes - topStartMinutes;
                const dragSpan = dragState.startMinutesEnd - dragState.startMinutesStart;
                
                // This check should never fail since we already checked above, but adding for safety
                if (dragSpan !== 0) {
                    const topRelativeStart = (topStartMinutes - dragState.startMinutesStart) / dragSpan;
                    topStartMinutes = bottomStartMinutes + topRelativeStart * (bottomEndMinutes - bottomStartMinutes);
                    topEndMinutes = topStartMinutes + topSpan;
                }
                
                // Ensure top stays within bottom bounds
                topStartMinutes = Math.max(bottomStartMinutes, Math.min(topStartMinutes, bottomEndMinutes - topSpan));
                topEndMinutes = topStartMinutes + topSpan;
            }
            
            updateRangeSliders();
            // Update the main view display to show the top timeline's range
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        function handleTopDrag(deltaMinutes) {
            const fineGranularity = getCurrentFineGranularity();
            const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
            
            // Calculate minimum span based on 20px minimum separation
            const minPixelSpan = calculateMinPixelSpan(dragState.wrapperRect.width, dragState.totalRange);
            
            // Use the larger of the time-based minimum or the pixel-based minimum
            const effectiveMinSpan = Math.max(minTopSpan, minPixelSpan);
            
            if (dragState.type === 'start') {
                let newStart = dragState.startMinutesStart + deltaMinutes;
                newStart = Math.max(bottomStartMinutes, newStart);
                newStart = Math.min(newStart, topEndMinutes - effectiveMinSpan);
                topStartMinutes = newStart;
            } else if (dragState.type === 'end') {
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                newEnd = Math.min(bottomEndMinutes, newEnd);
                newEnd = Math.max(newEnd, topStartMinutes + effectiveMinSpan);
                topEndMinutes = newEnd;
            } else if (dragState.type === 'range') {
                const span = dragState.startMinutesEnd - dragState.startMinutesStart;
                let newStart = dragState.startMinutesStart + deltaMinutes;
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                
                // Keep within bottom timeline bounds
                if (newStart < bottomStartMinutes) {
                    newStart = bottomStartMinutes;
                    newEnd = newStart + span;
                }
                if (newEnd > bottomEndMinutes) {
                    newEnd = bottomEndMinutes;
                    newStart = newEnd - span;
                }
                
                topStartMinutes = newStart;
                topEndMinutes = newEnd;
            }
            
            updateRangeSliders();
            // Update the main view display to show the top timeline's range
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        function endDrag() {
            dragState = null;
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', endDrag);
        }

        function updateViewFromTopTimeline() {
            viewStartMinutes = topStartMinutes;
            viewEndMinutes = topEndMinutes;
            currentViewMinutes = (topStartMinutes + topEndMinutes) / 2;
            
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        // Event listeners for bottom timeline
        bottomStartHandle.addEventListener('mousedown', (e) => startBottomDrag('start', e));
        bottomEndHandle.addEventListener('mousedown', (e) => startBottomDrag('end', e));
        bottomSelected.addEventListener('mousedown', (e) => startBottomDrag('range', e));

        // Event listeners for top timeline
        topStartHandle.addEventListener('mousedown', (e) => startTopDrag('start', e));
        topEndHandle.addEventListener('mousedown', (e) => startTopDrag('end', e));
        topSelected.addEventListener('mousedown', (e) => startTopDrag('range', e));

        // Add event listeners to all date component inputs
        const allDateInputs = [
            startEra, startYearComp, startMonth, startDay, startHour, startMinute,
            endEra, endYearComp, endMonth, endDay, endHour, endMinute
        ];
        
        allDateInputs.forEach(input => {
            input.addEventListener("change", () => {
                updateViewRange();
            });
            input.addEventListener("keydown", event => {
                if (event.key === "Enter") {
                    updateViewRange();
                }
            });
        });

        // Initialize
        initializeTimelines();
        updateDateInputs();
        updateRangeSliders();
        refreshRangeDisplay();
        rebuildTicks();
        updatePointerAndDetails();
    </script>
</body>
</html>
