<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Deep Time Timeline Explorer</title>
    <style>
        :root {
            color-scheme: light;
            font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            --accent: #0ea5e9;
            --accent-dark: #0284c7;
            --surface: rgba(255, 255, 255, 0.88);
            --shadow: 0 25px 60px rgba(15, 23, 42, 0.18);
            --text-muted: #475569;
            --future-accent: #a855f7;
            --future-accent-dark: #7e22ce;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem 1.5rem;
            background: radial-gradient(circle at top, #f0f9ff, #dbeafe 45%, #c7d2fe 100%);
            color: #0f172a;
        }

        .app {
            width: min(1080px, 100%);
            background: var(--surface);
            border-radius: 28px;
            overflow: hidden;
            box-shadow: var(--shadow);
            backdrop-filter: blur(12px);
        }

        header {
            padding: 2.5rem 3rem 2rem;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.9), rgba(6, 182, 212, 0.9));
            color: white;
        }

        header h1 {
            margin: 0 0 0.75rem;
            font-size: clamp(2rem, 3vw, 2.6rem);
            letter-spacing: 0.02em;
        }

        header p {
            margin: 0;
            max-width: 720px;
            font-size: 1.05rem;
            line-height: 1.6;
        }

        .panel {
            padding: 2.5rem 3rem 2rem;
            background: rgba(248, 250, 252, 0.9);
        }

        .control-grid {
            display: grid;
            gap: 1.8rem;
        }

        .control-row {
            display: grid;
            gap: 0.5rem;
        }

        label {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        select,
        input[type="number"] {
            width: 100%;
            border-radius: 14px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            padding: 0.9rem 1rem;
            font-size: 1rem;
            transition: border 0.2s ease, box-shadow 0.2s ease;
            background: white;
        }

        select:focus,
        input[type="number"]:focus {
            outline: none;
            border-color: rgba(14, 165, 233, 0.7);
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.2);
        }

        .control-row input[type="range"] {
            width: 100%;
            margin-top: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .date-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .date-field {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .field-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .date-field input[type="number"],
        .date-field select {
            padding: 0.6rem 0.5rem;
            font-size: 0.9rem;
        }

        .hint {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .controls-footer {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
        }

        button {
            border: none;
            border-radius: 999px;
            padding: 0.85rem 1.6rem;
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: white;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 15px 30px rgba(2, 132, 199, 0.25);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 20px 40px rgba(2, 132, 199, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .timeline-card {
            padding: 2.5rem 3rem 3rem;
            display: grid;
            gap: 1.5rem;
            background: white;
        }

        .timeline-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem 2rem;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        .timeline-meta strong {
            color: #0f172a;
        }

        .range-display {
            border-radius: 18px;
            padding: 1rem 1.25rem;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.08), rgba(59, 130, 246, 0.12));
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .slider-area {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .slider-area label {
            color: #0f172a;
        }

        .dual-timeline-container {
            margin-top: 1rem;
        }
        
        .timeline-with-vertical-controls {
            display: flex;
            align-items: stretch;
            gap: 12px;
        }
        
        .horizontal-sliders-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            flex: 1;
        }

        .range-slider-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .range-slider-label {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-muted);
        }

        .range-slider-wrapper {
            position: relative;
            height: 50px;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.15), rgba(37, 99, 235, 0.15));
            border-radius: 12px;
            padding: 0 12px;
            flex: 1;
        }

        .range-slider-track {
            position: absolute;
            top: 50%;
            left: 12px;
            right: 12px;
            height: 8px;
            transform: translateY(-50%);
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.3);
        }

        .range-slider-selected {
            position: absolute;
            top: 50%;
            height: 8px;
            transform: translateY(-50%);
            border-radius: 999px;
            background: linear-gradient(90deg, var(--accent), var(--accent-dark));
            cursor: grab;
        }

        .range-slider-selected:active {
            cursor: grabbing;
        }

        .range-slider-selected.future {
            background: linear-gradient(90deg, var(--future-accent), var(--future-accent-dark));
        }

        .range-handle {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            border: 3px solid white;
            z-index: 10;
        }

        .range-handle:hover {
            transform: translate(-50%, -50%) scale(1.15);
        }

        .range-handle:active {
            transform: translate(-50%, -50%) scale(1.05);
        }

        /* Vertical slider controls container */
        .vertical-slider-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-width: 100px;
            align-self: stretch; /* Match parent height */
        }

        .vertical-slider-control.start {
            align-items: flex-start;
        }

        .vertical-slider-control.end {
            align-items: flex-end;
        }

        /* Vertical sliders wrapper - should stretch to match horizontal sliders height */
        .vertical-sliders-wrapper {
            display: flex;
            gap: 12px;
            align-items: stretch;
            flex: 1;
            min-height: 0; /* Allow flex children to shrink properly */
        }
        
        .vertical-slider-with-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            flex: 1;
            min-height: 0; /* Allow flex children to shrink */
        }
        
        .slider-micro-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            text-align: center;
        }
        
        .granularity-display {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--accent);
            text-align: center;
            padding: 2px 4px;
            background: rgba(14, 165, 233, 0.1);
            border-radius: 4px;
            min-width: 60px;
        }

        /* Individual vertical slider */
        .vertical-slider {
            width: 40px;
            background: linear-gradient(180deg, rgba(14, 165, 233, 0.15), rgba(37, 99, 235, 0.15));
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            flex: 1 1 100px; /* Grow and shrink with 100px base */
            min-height: 100px; /* Ensure minimum visible height */
        }

        .vertical-slider-track {
            position: absolute;
            left: 50%;
            top: 12px;
            bottom: 12px;
            width: 8px;
            transform: translateX(-50%);
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.3);
        }

        .vertical-slider-handle {
            position: absolute;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            border: 3px solid white;
            z-index: 10;
            pointer-events: none;
        }

        .vertical-slider-handle:hover {
            transform: translate(-50%, -50%) scale(1.15);
        }

        /* Date display below sliders */
        .slider-date-display {
            font-size: 0.85rem;
            color: #0f172a;
            font-weight: 600;
            padding: 0.5rem 0.75rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
            max-width: 200px;
        }

        .slider-date-display.start {
            text-align: left;
        }

        .slider-date-display.end {
            text-align: right;
        }

        /* Speed slider at bottom center */
        .speed-slider-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
            padding: 1rem;
            width: 100%;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .speed-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 10px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.25), rgba(37, 99, 235, 0.25));
            outline: none;
            cursor: pointer;
            max-width: 300px;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(14, 165, 233, 0.3);
            border: 3px solid white;
        }

        .speed-slider::-moz-range-thumb {
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 8px 16px rgba(14, 165, 233, 0.3);
            border: 3px solid white;
            border: none;
        }

        .speed-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-muted);
            min-width: 50px;
            text-align: center;
        }

        .range-slider-info {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        /* Geologic period segments */
        .geologic-segments-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            border-radius: 999px;
            overflow: hidden;
        }

        .geologic-segment {
            position: absolute;
            height: 100%;
            cursor: pointer;
            transition: opacity 0.2s ease, filter 0.2s ease;
            border-right: 1px solid rgba(0, 0, 0, 0.1);
        }

        .geologic-segment:hover {
            filter: brightness(1.15);
            opacity: 0.95;
            z-index: 5;
        }

        /* Geologic period tooltip */
        .geologic-tooltip {
            position: fixed;
            background: white;
            border-radius: 12px;
            padding: 1rem 1.25rem;
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.25);
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease;
            border: 1px solid rgba(148, 163, 184, 0.25);
            max-width: 300px;
        }

        .geologic-tooltip.visible {
            opacity: 1;
        }

        .geologic-tooltip-header {
            font-weight: 700;
            font-size: 1rem;
            color: #0f172a;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid;
        }

        .geologic-tooltip-row {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.35rem;
            font-size: 0.9rem;
        }

        .geologic-tooltip-label {
            font-weight: 600;
            color: var(--text-muted);
            min-width: 60px;
        }

        .geologic-tooltip-value {
            color: #0f172a;
        }

        .geologic-tooltip-dates {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(148, 163, 184, 0.2);
            font-size: 0.85rem;
            color: var(--text-muted);
            font-style: italic;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 14px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.25), rgba(37, 99, 235, 0.25));
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 12px 20px rgba(14, 165, 233, 0.25);
            border: 3px solid white;
        }

        input[type="range"]::-moz-range-thumb {
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            cursor: pointer;
            box-shadow: 0 12px 20px rgba(14, 165, 233, 0.25);
            border: 3px solid white;
        }

        .timeline {
            position: relative;
            border-radius: 22px;
            padding: 3.2rem 2.2rem 3.5rem;
            background: radial-gradient(circle at top, rgba(14, 165, 233, 0.12), rgba(59, 130, 246, 0.08)),
                linear-gradient(135deg, rgba(148, 163, 184, 0.2), rgba(148, 163, 184, 0.05));
            overflow: visible;
        }

        .timeline-inner {
            position: relative;
            margin: 0 2rem;
        }

        .timeline-track {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 10px;
            transform: translateY(-50%);
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(14, 165, 233, 0.3), rgba(2, 132, 199, 0.6), rgba(14, 165, 233, 0.3));
            box-shadow: inset 0 0 12px rgba(14, 165, 233, 0.35);
        }

        .timeline-ticks {
            position: relative;
            min-height: 140px;
        }

        .tick {
            position: absolute;
            top: 0;
            transform: translateX(-50%);
            text-align: center;
            color: var(--text-muted);
            width: 120px;
        }

        .tick.future .tick-line {
            background: linear-gradient(180deg, rgba(168, 85, 247, 0.25), rgba(168, 85, 247, 0));
        }

        .tick.future .tick-label {
            color: #7e22ce;
        }

        .tick-line {
            display: block;
            margin: 0 auto 0.6rem;
            width: 2px;
            height: 32px;
            background: linear-gradient(180deg, rgba(14, 165, 233, 0.25), rgba(14, 165, 233, 0));
        }

        .tick-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #1e293b;
            text-shadow: 0 1px 2px rgba(148, 163, 184, 0.35);
            display: block;
            line-height: 1.3;
        }

        .pointer {
            position: absolute;
            top: 28%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.4rem;
            pointer-events: none;
        }

        .pointer::after {
            content: "";
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            box-shadow: 0 0 0 8px rgba(14, 165, 233, 0.18);
        }

        .pointer-label {
            padding: 0.35rem 0.75rem;
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.92), rgba(2, 132, 199, 0.92));
            color: white;
            font-size: 0.78rem;
            letter-spacing: 0.03em;
            text-transform: uppercase;
            box-shadow: 0 12px 24px rgba(14, 165, 233, 0.35);
        }

        .current-time {
            border-radius: 20px;
            padding: 1.5rem 1.75rem;
            background: linear-gradient(135deg, rgba(240, 249, 255, 0.7), rgba(224, 242, 254, 0.85));
            box-shadow: inset 0 0 0 1px rgba(14, 165, 233, 0.25);
            display: grid;
            gap: 0.65rem;
            font-size: 1rem;
        }

        .current-time h3 {
            margin: 0;
            font-size: 1.05rem;
            color: #0f172a;
            letter-spacing: 0.01em;
        }

        .current-time span {
            color: var(--text-muted);
        }

        .footnote {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.6;
        }

        @media (min-width: 720px) {
            .control-grid {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }

            .control-row:nth-child(2),
            .control-row:nth-child(3) {
                grid-column: span 1;
            }

            .controls-footer {
                grid-column: span 3;
                justify-content: space-between;
            }
        }

        @media (max-width: 640px) {
            header,
            .panel,
            .timeline-card {
                padding: 2rem 1.5rem;
            }

            .tick {
                width: 96px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <section class="timeline-card">
            <div class="range-display" id="rangeDisplay"></div>
            <div class="dual-timeline-container">
                <div class="timeline-with-vertical-controls">
                    <!-- Start Date Vertical Sliders (left side) -->
                    <div class="vertical-slider-control start">
                        <div class="vertical-sliders-wrapper">
                            <div class="vertical-slider-with-label">
                                <div class="slider-micro-label">Granularity</div>
                                <div class="vertical-slider" id="startGranularitySlider">
                                    <div class="vertical-slider-track"></div>
                                    <div class="vertical-slider-handle" id="startGranularityHandle"></div>
                                </div>
                                <div class="granularity-display" id="startGranularityDisplay">Year</div>
                            </div>
                            <div class="vertical-slider-with-label">
                                <div class="slider-micro-label">Adjust Date</div>
                                <div class="vertical-slider" id="startDateSlider">
                                    <div class="vertical-slider-track"></div>
                                    <div class="vertical-slider-handle" id="startDateHandle"></div>
                                </div>
                            </div>
                        </div>
                        <div class="slider-date-display start" id="startDateDisplay"></div>
                    </div>
                    
                    <!-- Timeline sliders container -->
                    <div class="horizontal-sliders-container">
                        <!-- Top Timeline: Fine Range Selector -->
                        <div class="range-slider-container">
                            <div class="range-slider-wrapper" id="topSliderWrapper">
                                <div class="range-slider-track" id="topSliderTrack">
                                    <div class="geologic-segments-container" id="topGeologicSegments"></div>
                                </div>
                                <div class="range-slider-selected" id="topSelected"></div>
                                <div class="range-handle" id="topStartHandle"></div>
                                <div class="range-handle" id="topEndHandle"></div>
                            </div>
                        </div>

                        <!-- Bottom Timeline: Coarse Range Selector -->
                        <div class="range-slider-container">
                            <div class="range-slider-wrapper" id="bottomSliderWrapper">
                                <div class="range-slider-track" id="bottomSliderTrack">
                                    <div class="geologic-segments-container" id="bottomGeologicSegments"></div>
                                </div>
                                <div class="range-slider-selected" id="bottomSelected"></div>
                                <div class="range-handle" id="bottomStartHandle"></div>
                                <div class="range-handle" id="bottomEndHandle"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- End Date Vertical Sliders (right side) -->
                    <div class="vertical-slider-control end">
                        <div class="vertical-sliders-wrapper">
                            <div class="vertical-slider-with-label">
                                <div class="slider-micro-label">Adjust Date</div>
                                <div class="vertical-slider" id="endDateSlider">
                                    <div class="vertical-slider-track"></div>
                                    <div class="vertical-slider-handle" id="endDateHandle"></div>
                                </div>
                            </div>
                            <div class="vertical-slider-with-label">
                                <div class="slider-micro-label">Granularity</div>
                                <div class="vertical-slider" id="endGranularitySlider">
                                    <div class="vertical-slider-track"></div>
                                    <div class="vertical-slider-handle" id="endGranularityHandle"></div>
                                </div>
                                <div class="granularity-display" id="endGranularityDisplay">Year</div>
                            </div>
                        </div>
                        <div class="slider-date-display end" id="endDateDisplay"></div>
                    </div>
                </div>
            </div>
            
            <!-- Speed slider at bottom center -->
            <div class="speed-slider-container">
                <span class="speed-label">Slow</span>
                <input type="range" class="speed-slider" id="speedSlider" min="1" max="100" value="50" step="1">
                <span class="speed-label">Fast</span>
            </div>
        </section>
    </div>

    <!-- Geologic period tooltip -->
    <div class="geologic-tooltip" id="geologicTooltip">
        <div class="geologic-tooltip-header" id="tooltipHeader"></div>
        <div class="geologic-tooltip-row">
            <span class="geologic-tooltip-label">Eon:</span>
            <span class="geologic-tooltip-value" id="tooltipEon"></span>
        </div>
        <div class="geologic-tooltip-row">
            <span class="geologic-tooltip-label">Era:</span>
            <span class="geologic-tooltip-value" id="tooltipEra"></span>
        </div>
        <div class="geologic-tooltip-row">
            <span class="geologic-tooltip-label">Period:</span>
            <span class="geologic-tooltip-value" id="tooltipPeriod"></span>
        </div>
        <div class="geologic-tooltip-row">
            <span class="geologic-tooltip-label">Epoch:</span>
            <span class="geologic-tooltip-value" id="tooltipEpoch"></span>
        </div>
        <div class="geologic-tooltip-dates" id="tooltipDates"></div>
    </div>

    <script>
        const MINUTES_PER_YEAR = 525600;
        const MINUTES_PER_MONTH = MINUTES_PER_YEAR / 12;
        const MINUTES_PER_WEEK = 10080;
        const MINUTES_PER_DAY = 1440;
        const MINUTES_PER_HOUR = 60;

        const EARTH_AGE_YEARS = 4_540_000_000;
        const HALF_SPAN_MINUTES = EARTH_AGE_YEARS * MINUTES_PER_YEAR;
        const TIMELINE_MIN = -HALF_SPAN_MINUTES;
        const TIMELINE_MAX = HALF_SPAN_MINUTES;

        // Calculate current date in timeline minutes
        function getCurrentDateMinutes() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth() + 1; // JavaScript months are 0-indexed
            const day = now.getDate();
            const hour = now.getHours();
            const minute = now.getMinutes();
            
            // Year 1 CE is at 0 minutes, so we calculate from there
            let totalMinutes = (year - 1) * MINUTES_PER_YEAR;
            totalMinutes += (month - 1) * MINUTES_PER_MONTH;
            totalMinutes += (day - 1) * MINUTES_PER_DAY;
            totalMinutes += hour * MINUTES_PER_HOUR;
            totalMinutes += minute;
            
            return totalMinutes;
        }
        
        const CURRENT_DATE_MINUTES = getCurrentDateMinutes();
        
        // Calculate default range: from last week to tomorrow night
        const LAST_WEEK_MINUTES = CURRENT_DATE_MINUTES - (7 * MINUTES_PER_DAY);
        // Tomorrow night = end of tomorrow day (23:59)
        // First, calculate minutes elapsed today
        const now = new Date();
        const minutesTodaySoFar = now.getHours() * MINUTES_PER_HOUR + now.getMinutes();
        // Tomorrow night is: go back to start of today, forward 2 days, minus 1 minute
        const TOMORROW_NIGHT_MINUTES = CURRENT_DATE_MINUTES - minutesTodaySoFar + (2 * MINUTES_PER_DAY) - 1;

        const GRANULARITY_TO_MINUTES = {
            Eon: MINUTES_PER_YEAR * 500_000_000,
            Epoch: MINUTES_PER_YEAR * 50_000_000,
            Age: MINUTES_PER_YEAR * 5_000_000,
            Millennium: MINUTES_PER_YEAR * 1_000,
            Century: MINUTES_PER_YEAR * 100,
            Decade: MINUTES_PER_YEAR * 10,
            Year: MINUTES_PER_YEAR,
            Month: MINUTES_PER_MONTH,
            Week: MINUTES_PER_WEEK,
            Day: MINUTES_PER_DAY,
            Hour: MINUTES_PER_HOUR,
            Minute: 1
        };

        const UNIT_LABELS = {
            Eon: { singular: "eon", plural: "eons" },
            Epoch: { singular: "epoch", plural: "epochs" },
            Age: { singular: "age", plural: "ages" },
            Millennium: { singular: "millennium", plural: "millennia" },
            Century: { singular: "century", plural: "centuries" },
            Decade: { singular: "decade", plural: "decades" },
            Year: { singular: "year", plural: "years" },
            Month: { singular: "month", plural: "months" },
            Week: { singular: "week", plural: "weeks" },
            Day: { singular: "day", plural: "days" },
            Hour: { singular: "hour", plural: "hours" },
            Minute: { singular: "minute", plural: "minutes" }
        };

        // Geologic Time Periods Data
        // Based on the International Commission on Stratigraphy (ICS) timescale
        // All dates are in millions of years ago (Ma), converted to BCE years
        // Note: BCE years are negative in our timeline system
        const GEOLOGIC_PERIODS = [
            // PHANEROZOIC EON
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Quaternary",
                epoch: "Holocene",
                startMya: 0.0117,
                endMya: 0,
                color: "#FEF2E0"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Quaternary",
                epoch: "Pleistocene",
                startMya: 2.58,
                endMya: 0.0117,
                color: "#FFF2CC"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Neogene",
                epoch: "Pliocene",
                startMya: 5.333,
                endMya: 2.58,
                color: "#FFFF99"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Neogene",
                epoch: "Miocene",
                startMya: 23.03,
                endMya: 5.333,
                color: "#FFFF00"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Paleogene",
                epoch: "Oligocene",
                startMya: 33.9,
                endMya: 23.03,
                color: "#FED8B1"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Paleogene",
                epoch: "Eocene",
                startMya: 56.0,
                endMya: 33.9,
                color: "#FDC07A"
            },
            {
                eon: "Phanerozoic",
                era: "Cenozoic",
                period: "Paleogene",
                epoch: "Paleocene",
                startMya: 66.0,
                endMya: 56.0,
                color: "#FDA75F"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Cretaceous",
                epoch: "Late Cretaceous",
                startMya: 100.5,
                endMya: 66.0,
                color: "#7FC64E"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Cretaceous",
                epoch: "Early Cretaceous",
                startMya: 145.0,
                endMya: 100.5,
                color: "#8FD14F"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Jurassic",
                epoch: "Late Jurassic",
                startMya: 163.5,
                endMya: 145.0,
                color: "#34B2C9"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Jurassic",
                epoch: "Middle Jurassic",
                startMya: 174.7,
                endMya: 163.5,
                color: "#5FC4D3"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Jurassic",
                epoch: "Early Jurassic",
                startMya: 201.4,
                endMya: 174.7,
                color: "#7AD5DD"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Triassic",
                epoch: "Late Triassic",
                startMya: 237.0,
                endMya: 201.4,
                color: "#983999"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Triassic",
                epoch: "Middle Triassic",
                startMya: 247.2,
                endMya: 237.0,
                color: "#B051A5"
            },
            {
                eon: "Phanerozoic",
                era: "Mesozoic",
                period: "Triassic",
                epoch: "Early Triassic",
                startMya: 251.9,
                endMya: 247.2,
                color: "#C869B0"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Permian",
                epoch: "Lopingian",
                startMya: 259.1,
                endMya: 251.9,
                color: "#F04028"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Permian",
                epoch: "Guadalupian",
                startMya: 273.0,
                endMya: 259.1,
                color: "#F36E4C"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Permian",
                epoch: "Cisuralian",
                startMya: 298.9,
                endMya: 273.0,
                color: "#F69A70"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Carboniferous",
                epoch: "Pennsylvanian",
                startMya: 323.2,
                endMya: 298.9,
                color: "#67A599"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Carboniferous",
                epoch: "Mississippian",
                startMya: 358.9,
                endMya: 323.2,
                color: "#8CB4A9"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Devonian",
                epoch: "Late Devonian",
                startMya: 382.7,
                endMya: 358.9,
                color: "#CB8C37"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Devonian",
                epoch: "Middle Devonian",
                startMya: 393.3,
                endMya: 382.7,
                color: "#D9A85A"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Devonian",
                epoch: "Early Devonian",
                startMya: 419.2,
                endMya: 393.3,
                color: "#E7C37D"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Silurian",
                epoch: "Pridoli",
                startMya: 423.0,
                endMya: 419.2,
                color: "#B3E1E6"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Silurian",
                epoch: "Ludlow",
                startMya: 427.4,
                endMya: 423.0,
                color: "#B3E1E6"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Silurian",
                epoch: "Wenlock",
                startMya: 433.4,
                endMya: 427.4,
                color: "#B3E1E6"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Silurian",
                epoch: "Llandovery",
                startMya: 443.8,
                endMya: 433.4,
                color: "#B3E1E6"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Ordovician",
                epoch: "Late Ordovician",
                startMya: 458.4,
                endMya: 443.8,
                color: "#009270"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Ordovician",
                epoch: "Middle Ordovician",
                startMya: 470.0,
                endMya: 458.4,
                color: "#26A789"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Ordovician",
                epoch: "Early Ordovician",
                startMya: 485.4,
                endMya: 470.0,
                color: "#4DBCA2"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Cambrian",
                epoch: "Furongian",
                startMya: 497.0,
                endMya: 485.4,
                color: "#7FA056"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Cambrian",
                epoch: "Series 3",
                startMya: 509.0,
                endMya: 497.0,
                color: "#8DB06C"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Cambrian",
                epoch: "Series 2",
                startMya: 521.0,
                endMya: 509.0,
                color: "#9BC082"
            },
            {
                eon: "Phanerozoic",
                era: "Paleozoic",
                period: "Cambrian",
                epoch: "Terreneuvian",
                startMya: 538.8,
                endMya: 521.0,
                color: "#A9D098"
            },
            // PROTEROZOIC EON
            {
                eon: "Proterozoic",
                era: "Neoproterozoic",
                period: "Ediacaran",
                epoch: "Ediacaran",
                startMya: 635.0,
                endMya: 538.8,
                color: "#FED99C"
            },
            {
                eon: "Proterozoic",
                era: "Neoproterozoic",
                period: "Cryogenian",
                epoch: "Cryogenian",
                startMya: 720.0,
                endMya: 635.0,
                color: "#FECC9F"
            },
            {
                eon: "Proterozoic",
                era: "Neoproterozoic",
                period: "Tonian",
                epoch: "Tonian",
                startMya: 1000.0,
                endMya: 720.0,
                color: "#FEBFA2"
            },
            {
                eon: "Proterozoic",
                era: "Mesoproterozoic",
                period: "Stenian",
                epoch: "Stenian",
                startMya: 1200.0,
                endMya: 1000.0,
                color: "#FDB46C"
            },
            {
                eon: "Proterozoic",
                era: "Mesoproterozoic",
                period: "Ectasian",
                epoch: "Ectasian",
                startMya: 1400.0,
                endMya: 1200.0,
                color: "#FCA75B"
            },
            {
                eon: "Proterozoic",
                era: "Mesoproterozoic",
                period: "Calymmian",
                epoch: "Calymmian",
                startMya: 1600.0,
                endMya: 1400.0,
                color: "#FC9A4A"
            },
            {
                eon: "Proterozoic",
                era: "Paleoproterozoic",
                period: "Statherian",
                epoch: "Statherian",
                startMya: 1800.0,
                endMya: 1600.0,
                color: "#F48C61"
            },
            {
                eon: "Proterozoic",
                era: "Paleoproterozoic",
                period: "Orosirian",
                epoch: "Orosirian",
                startMya: 2050.0,
                endMya: 1800.0,
                color: "#F27E75"
            },
            {
                eon: "Proterozoic",
                era: "Paleoproterozoic",
                period: "Rhyacian",
                epoch: "Rhyacian",
                startMya: 2300.0,
                endMya: 2050.0,
                color: "#F07089"
            },
            {
                eon: "Proterozoic",
                era: "Paleoproterozoic",
                period: "Siderian",
                epoch: "Siderian",
                startMya: 2500.0,
                endMya: 2300.0,
                color: "#EF629D"
            },
            // ARCHEAN EON
            {
                eon: "Archean",
                era: "Neoarchean",
                period: "Neoarchean",
                epoch: "Neoarchean",
                startMya: 2800.0,
                endMya: 2500.0,
                color: "#F2A4C6"
            },
            {
                eon: "Archean",
                era: "Mesoarchean",
                period: "Mesoarchean",
                epoch: "Mesoarchean",
                startMya: 3200.0,
                endMya: 2800.0,
                color: "#F5B5D4"
            },
            {
                eon: "Archean",
                era: "Paleoarchean",
                period: "Paleoarchean",
                epoch: "Paleoarchean",
                startMya: 3600.0,
                endMya: 3200.0,
                color: "#F8C6E2"
            },
            {
                eon: "Archean",
                era: "Eoarchean",
                period: "Eoarchean",
                epoch: "Eoarchean",
                startMya: 4000.0,
                endMya: 3600.0,
                color: "#FBD7F0"
            },
            // HADEAN EON
            {
                eon: "Hadean",
                era: "Hadean",
                period: "Hadean",
                epoch: "Hadean",
                startMya: 4540.0,
                endMya: 4000.0,
                color: "#D4C5C0"
            }
        ];

        // Convert Mya (millions of years ago) to timeline minutes (BCE)
        function myaToMinutes(mya) {
            // Mya = millions of years ago, which are BCE years
            // BCE years are negative in our system
            const yearsAgo = mya * 1_000_000;
            return -yearsAgo * MINUTES_PER_YEAR;
        }

        // Add timeline minutes to each geologic period
        GEOLOGIC_PERIODS.forEach(period => {
            period.startMinutes = myaToMinutes(period.startMya);
            period.endMinutes = myaToMinutes(period.endMya);
        });

        const compactFormatter = new Intl.NumberFormat("en-US", {
            notation: "compact",
            maximumFractionDigits: 1
        });
        const numberFormatter = new Intl.NumberFormat("en-US");
        
        // Custom formatter for years: no commas for 4-digit years (1000-9999)
        function formatYear(year) {
            const absYear = Math.abs(year);
            if (absYear >= 1000 && absYear <= 9999) {
                return absYear.toString();
            }
            return numberFormatter.format(absYear);
        }
        
        const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        
        const rangeDisplay = document.getElementById("rangeDisplay");
        
        // Speed slider elements
        const speedSlider = document.getElementById("speedSlider");
        let speedMultiplier = 1.0; // Default to 50% (value=50, which gives speedMultiplier=1.0)
        
        // Vertical slider elements
        const startGranularitySlider = document.getElementById("startGranularitySlider");
        const startGranularityHandle = document.getElementById("startGranularityHandle");
        const startGranularityDisplay = document.getElementById("startGranularityDisplay");
        const startDateSlider = document.getElementById("startDateSlider");
        const startDateHandle = document.getElementById("startDateHandle");
        const startDateDisplay = document.getElementById("startDateDisplay");
        
        const endGranularitySlider = document.getElementById("endGranularitySlider");
        const endGranularityHandle = document.getElementById("endGranularityHandle");
        const endGranularityDisplay = document.getElementById("endGranularityDisplay");
        const endDateSlider = document.getElementById("endDateSlider");
        const endDateHandle = document.getElementById("endDateHandle");
        const endDateDisplay = document.getElementById("endDateDisplay");

        // Bottom timeline elements
        const bottomSliderWrapper = document.getElementById("bottomSliderWrapper");
        const bottomSliderTrack = document.getElementById("bottomSliderTrack");
        const bottomSelected = document.getElementById("bottomSelected");
        const bottomStartHandle = document.getElementById("bottomStartHandle");
        const bottomEndHandle = document.getElementById("bottomEndHandle");

        // Top timeline elements
        const topSliderWrapper = document.getElementById("topSliderWrapper");
        const topSliderTrack = document.getElementById("topSliderTrack");
        const topSelected = document.getElementById("topSelected");
        const topStartHandle = document.getElementById("topStartHandle");
        const topEndHandle = document.getElementById("topEndHandle");


        // Timeline state
        // Bottom timeline: user's coarse range selection (boundaries are TIMELINE_MIN to TIMELINE_MAX)
        let bottomStartMinutes = LAST_WEEK_MINUTES;
        let bottomEndMinutes = TOMORROW_NIGHT_MINUTES;
        // Top timeline: user's fine range selection (boundaries are bottomStart to bottomEnd)
        let topStartMinutes = LAST_WEEK_MINUTES;
        let topEndMinutes = TOMORROW_NIGHT_MINUTES;

        let viewStartMinutes = LAST_WEEK_MINUTES;
        let viewEndMinutes = TOMORROW_NIGHT_MINUTES;
        let currentViewMinutes = 0; // Current position shown on the timeline
        
        // Track manual fine granularity override (null means auto-calculate)
        let manualFineGranularity = null;
        
        // Vertical slider state
        const GRANULARITY_LEVELS = Object.keys(GRANULARITY_TO_MINUTES); // Ordered from coarsest to finest
        let startGranularityIndex = 6; // Default to Year (index 6)
        let endGranularityIndex = 6;
        
        // Date adjustment animation state
        let startDateAdjustmentInterval = null;
        let endDateAdjustmentInterval = null;

        function getGranularityIndex(granularity) {
            const granularities = Object.keys(GRANULARITY_TO_MINUTES);
            return granularities.indexOf(granularity);
        }

        function getGranularityTwoLevelsLess(granularity) {
            const granularities = Object.keys(GRANULARITY_TO_MINUTES);
            const currentIndex = getGranularityIndex(granularity);
            const targetIndex = Math.min(currentIndex + 2, granularities.length - 1);
            return granularities[targetIndex];
        }
        
        // Get the current fine granularity (manual override or auto-calculated)
        function getCurrentFineGranularity() {
            if (manualFineGranularity) {
                return manualFineGranularity;
            }
            const bottomSpan = bottomEndMinutes - bottomStartMinutes;
            return calculateFineGranularity(bottomSpan);
        }

        // Calculate appropriate fine granularity based on the span of the bottom slider's range
        // The goal is to find a granularity such that the fine slider takes up approximately
        // 1/4 of the track width while providing smooth navigation
        function calculateFineGranularity(spanMinutes) {
            const granularities = Object.keys(GRANULARITY_TO_MINUTES);
            const granularityValues = Object.values(GRANULARITY_TO_MINUTES);
            
            // Target: fine slider should span about 1/4 of the bottom slider's range
            // This means we want a granularity where 10-40 units fit in 1/4 of the span
            const targetSpan = spanMinutes / 4;
            
            // Find the COARSEST granularity where we have at least 10 units in the target span
            // Start from coarsest and work toward finer
            for (let i = 0; i < granularities.length; i++) {
                const unitMinutes = granularityValues[i];
                const numUnitsInQuarter = targetSpan / unitMinutes;
                
                // We want at least 10 units to provide smooth sliding
                if (numUnitsInQuarter >= 10) {
                    return granularities[i];
                }
            }
            
            // If even the finest granularity doesn't give us 10 units, use it anyway
            return granularities[granularities.length - 1];
        }

        function initializeTimelines() {
            // Bottom timeline (coarse selector) is already set to LAST_WEEK to TOMORROW_NIGHT
            // Just need to set the top timeline to fit within it
            
            // Set top timeline to take up a portion of bottom range width
            const topMidpoint = (bottomStartMinutes + bottomEndMinutes) / 2;
            const topHalfSpan = (bottomEndMinutes - bottomStartMinutes) / 8; // 1/8 to get 1/4 total
            topStartMinutes = topMidpoint - topHalfSpan;
            topEndMinutes = topMidpoint + topHalfSpan;
            
            // Set view to show the top timeline's range
            currentViewMinutes = topMidpoint;
        }

        function clampMinutes(value) {
            return Math.min(Math.max(value, TIMELINE_MIN), TIMELINE_MAX);
        }

        // Convert date components to minutes from center
        function dateComponentsToMinutes(era, year, month, day, hour, minute) {
            const eraSign = parseInt(era);
            const y = parseInt(year) || 1;
            const m = parseInt(month) || 1;
            const d = parseInt(day) || 1;
            const h = parseInt(hour) || 0;
            const min = parseInt(minute) || 0;
            
            // Calculate total minutes from year 1 CE (which is at 0 minutes)
            let totalMinutes = 0;
            
            if (eraSign === 1) {
                // CE: Year 1 CE starts at 0, Year 2 CE starts at MINUTES_PER_YEAR, etc.
                totalMinutes = (y - 1) * MINUTES_PER_YEAR;
                totalMinutes += (m - 1) * MINUTES_PER_MONTH;
                totalMinutes += (d - 1) * MINUTES_PER_DAY;
                totalMinutes += h * MINUTES_PER_HOUR;
                totalMinutes += min;
            } else {
                // BCE: Year 1 BCE starts at -MINUTES_PER_YEAR, Year 2 BCE starts at -2*MINUTES_PER_YEAR, etc.
                // Within each year, months/days/hours/minutes add forward (Jan=left, Dec=right)
                totalMinutes = -(y * MINUTES_PER_YEAR);
                totalMinutes += (m - 1) * MINUTES_PER_MONTH;
                totalMinutes += (d - 1) * MINUTES_PER_DAY;
                totalMinutes += h * MINUTES_PER_HOUR;
                totalMinutes += min;
            }
            
            return totalMinutes;
        }

        // Convert minutes from center to date components
        function minutesToDateComponents(minutes) {
            if (minutes >= 0) {
                // CE: straightforward calculation
                let remaining = minutes;
                const years = Math.floor(remaining / MINUTES_PER_YEAR);
                remaining -= years * MINUTES_PER_YEAR;
                
                const months = Math.floor(remaining / MINUTES_PER_MONTH);
                remaining -= months * MINUTES_PER_MONTH;
                
                const days = Math.floor(remaining / MINUTES_PER_DAY);
                remaining -= days * MINUTES_PER_DAY;
                
                const hours = Math.floor(remaining / MINUTES_PER_HOUR);
                remaining -= hours * MINUTES_PER_HOUR;
                
                const mins = Math.floor(remaining);
                
                return {
                    era: 1,
                    year: years + 1,
                    month: months + 1,
                    day: days + 1,
                    hour: hours,
                    minute: mins
                };
            } else {
                // BCE: Year N BCE spans from -(N*MINUTES_PER_YEAR) to -((N-1)*MINUTES_PER_YEAR)
                const absMinutes = Math.abs(minutes);
                const years = Math.ceil(absMinutes / MINUTES_PER_YEAR);
                
                // Calculate the start of this year (most negative point)
                const yearStart = -(years * MINUTES_PER_YEAR);
                
                // Calculate offset from year start (positive for sub-year components)
                const offsetFromYearStart = minutes - yearStart;
                
                let remaining = offsetFromYearStart;
                const months = Math.floor(remaining / MINUTES_PER_MONTH);
                remaining -= months * MINUTES_PER_MONTH;
                
                const days = Math.floor(remaining / MINUTES_PER_DAY);
                remaining -= days * MINUTES_PER_DAY;
                
                const hours = Math.floor(remaining / MINUTES_PER_HOUR);
                remaining -= hours * MINUTES_PER_HOUR;
                
                const mins = Math.floor(remaining);
                
                return {
                    era: -1,
                    year: years,
                    month: months + 1,
                    day: days + 1,
                    hour: hours,
                    minute: mins
                };
            }
        }

        // Update the date displays below vertical sliders
        function updateDateDisplays() {
            // Date displays show the coarse track boundaries (controlled by vertical sliders)
            const startComponents = minutesToDateComponents(viewStartMinutes);
            const endComponents = minutesToDateComponents(viewEndMinutes);
            
            const startEra = startComponents.era === 1 ? "CE" : "BCE";
            const endEra = endComponents.era === 1 ? "CE" : "BCE";
            
            const startMonthIndex = Math.min(Math.max(startComponents.month - 1, 0), 11);
            const endMonthIndex = Math.min(Math.max(endComponents.month - 1, 0), 11);
            
            startDateDisplay.textContent = `${MONTH_NAMES[startMonthIndex]} ${startComponents.day}, ${formatYear(startComponents.year)} ${pad(startComponents.hour)}:${pad(startComponents.minute)} ${startEra}`;
            endDateDisplay.textContent = `${MONTH_NAMES[endMonthIndex]} ${endComponents.day}, ${formatYear(endComponents.year)} ${pad(endComponents.hour)}:${pad(endComponents.minute)} ${endEra}`;
        }
        
        // Update granularity slider handle positions
        function updateGranularitySliders() {
            // Start granularity slider (top = finest, bottom = coarsest)
            const startPercent = (1 - (startGranularityIndex / (GRANULARITY_LEVELS.length - 1))) * 100;
            startGranularityHandle.style.top = `${startPercent}%`;
            startGranularityDisplay.textContent = GRANULARITY_LEVELS[startGranularityIndex];
            
            // End granularity slider (top = finest, bottom = coarsest)
            const endPercent = (1 - (endGranularityIndex / (GRANULARITY_LEVELS.length - 1))) * 100;
            endGranularityHandle.style.top = `${endPercent}%`;
            endGranularityDisplay.textContent = GRANULARITY_LEVELS[endGranularityIndex];
        }
        
        // Initialize date adjustment sliders to center
        function resetDateSliders() {
            startDateHandle.style.top = '50%';
            endDateHandle.style.top = '50%';
        }

        // Geologic period visualization functions
        const topGeologicSegments = document.getElementById('topGeologicSegments');
        const bottomGeologicSegments = document.getElementById('bottomGeologicSegments');
        const geologicTooltip = document.getElementById('geologicTooltip');
        const tooltipHeader = document.getElementById('tooltipHeader');
        const tooltipEon = document.getElementById('tooltipEon');
        const tooltipEra = document.getElementById('tooltipEra');
        const tooltipPeriod = document.getElementById('tooltipPeriod');
        const tooltipEpoch = document.getElementById('tooltipEpoch');
        const tooltipDates = document.getElementById('tooltipDates');

        function renderGeologicSegments(container, rangeStartMinutes, rangeEndMinutes) {
            // Clear existing segments
            container.innerHTML = '';
            
            // Helper function to get the actual end time for a period (extends Holocene to present)
            const getPeriodEnd = (period) => (period.endMya === 0) ? CURRENT_DATE_MINUTES : period.endMinutes;
            
            // Find all periods that overlap with the visible range
            const visiblePeriods = GEOLOGIC_PERIODS.filter(period => {
                const periodEnd = getPeriodEnd(period);
                return periodEnd >= rangeStartMinutes && period.startMinutes <= rangeEndMinutes;
            });
            
            const totalRange = rangeEndMinutes - rangeStartMinutes;
            
            visiblePeriods.forEach(period => {
                const periodEnd = getPeriodEnd(period);
                
                // Calculate the visible portion of this period
                const segmentStart = Math.max(period.startMinutes, rangeStartMinutes);
                const segmentEnd = Math.min(periodEnd, rangeEndMinutes);
                
                // Calculate position as percentage
                const leftPercent = ((segmentStart - rangeStartMinutes) / totalRange) * 100;
                const widthPercent = ((segmentEnd - segmentStart) / totalRange) * 100;
                
                // Skip if the segment is too small to see (< 0.1%)
                if (widthPercent < 0.1) {
                    return;
                }
                
                // Create segment element
                const segment = document.createElement('div');
                segment.className = 'geologic-segment';
                segment.style.left = `${leftPercent}%`;
                segment.style.width = `${widthPercent}%`;
                segment.style.backgroundColor = period.color;
                
                // Add hover tooltip
                segment.addEventListener('mouseenter', (e) => {
                    showGeologicTooltip(period, e);
                });
                
                segment.addEventListener('mousemove', (e) => {
                    updateTooltipPosition(e);
                });
                
                segment.addEventListener('mouseleave', () => {
                    hideGeologicTooltip();
                });
                
                container.appendChild(segment);
            });
            
            // Add future segment if range extends into the future
            if (rangeEndMinutes > CURRENT_DATE_MINUTES && rangeStartMinutes < TIMELINE_MAX) {
                const futureStart = Math.max(CURRENT_DATE_MINUTES, rangeStartMinutes);
                const futureEnd = Math.min(TIMELINE_MAX, rangeEndMinutes);
                
                const leftPercent = ((futureStart - rangeStartMinutes) / totalRange) * 100;
                const widthPercent = ((futureEnd - futureStart) / totalRange) * 100;
                
                // Only render if visible (> 0.1%)
                if (widthPercent >= 0.1) {
                    const futureSegment = document.createElement('div');
                    futureSegment.className = 'geologic-segment';
                    futureSegment.style.left = `${leftPercent}%`;
                    futureSegment.style.width = `${widthPercent}%`;
                    futureSegment.style.backgroundColor = 'rgba(168, 85, 247, 0.3)'; // Purple for future
                    
                    // Add hover tooltip for future
                    futureSegment.addEventListener('mouseenter', (e) => {
                        showFutureTooltip(e);
                    });
                    
                    futureSegment.addEventListener('mousemove', (e) => {
                        updateTooltipPosition(e);
                    });
                    
                    futureSegment.addEventListener('mouseleave', () => {
                        hideGeologicTooltip();
                    });
                    
                    container.appendChild(futureSegment);
                }
            }
        }

        function showGeologicTooltip(period, event) {
            tooltipHeader.textContent = period.epoch;
            tooltipHeader.style.borderBottomColor = period.color;
            tooltipEon.textContent = period.eon;
            tooltipEra.textContent = period.era;
            tooltipPeriod.textContent = period.period;
            tooltipEpoch.textContent = period.epoch;
            
            // Format dates
            const startMya = period.startMya;
            const endMya = period.endMya;
            let dateText;
            if (endMya === 0) {
                dateText = `${startMya.toFixed(2)} Ma - Present`;
            } else {
                dateText = `${startMya.toFixed(2)} - ${endMya.toFixed(2)} Ma`;
            }
            tooltipDates.textContent = dateText;
            
            geologicTooltip.classList.add('visible');
            updateTooltipPosition(event);
        }

        function showFutureTooltip(event) {
            tooltipHeader.textContent = 'Future';
            tooltipHeader.style.borderBottomColor = 'rgba(168, 85, 247, 0.8)';
            tooltipEon.textContent = '';
            tooltipEra.textContent = '';
            tooltipPeriod.textContent = '';
            tooltipEpoch.textContent = 'Future';
            tooltipDates.textContent = 'Present onward';
            
            geologicTooltip.classList.add('visible');
            updateTooltipPosition(event);
        }

        function updateTooltipPosition(event) {
            const tooltipRect = geologicTooltip.getBoundingClientRect();
            const offset = 15;
            
            // Get the bounds of the dual-timeline-container
            const timelineContainer = document.querySelector('.dual-timeline-container');
            const containerRect = timelineContainer.getBoundingClientRect();
            
            let left = event.clientX + offset;
            let top = event.clientY + offset;
            
            // Constrain horizontally within the timeline container
            if (left + tooltipRect.width > containerRect.right) {
                left = event.clientX - tooltipRect.width - offset;
            }
            if (left < containerRect.left) {
                left = containerRect.left + offset;
            }
            
            // Constrain vertically within the timeline container
            if (top + tooltipRect.height > containerRect.bottom) {
                top = event.clientY - tooltipRect.height - offset;
            }
            if (top < containerRect.top) {
                top = containerRect.top + offset;
            }
            
            geologicTooltip.style.left = `${left}px`;
            geologicTooltip.style.top = `${top}px`;
        }

        function hideGeologicTooltip() {
            geologicTooltip.classList.remove('visible');
        }

        function updateViewRange() {
            // View range should provide reasonable boundaries around the bottom slider
            // Expand to 4x the current bottom range for comfortable viewing
            const bottomRange = bottomEndMinutes - bottomStartMinutes;
            const viewPadding = bottomRange * 1.5;
            viewStartMinutes = clampMinutes(bottomStartMinutes - viewPadding);
            viewEndMinutes = clampMinutes(bottomEndMinutes + viewPadding);
            
            // Ensure minimum view range
            const minViewRange = bottomRange * 4;
            if (viewEndMinutes - viewStartMinutes < minViewRange) {
                const midpoint = (viewStartMinutes + viewEndMinutes) / 2;
                viewStartMinutes = clampMinutes(midpoint - minViewRange / 2);
                viewEndMinutes = clampMinutes(midpoint + minViewRange / 2);
            }
            
            updateRangeSliders();
            updateDateDisplays();
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        function refreshRangeDisplay() {
            // Display the top timeline's current range with full date/time details
            const startComponents = minutesToDateComponents(topStartMinutes);
            const endComponents = minutesToDateComponents(topEndMinutes);
            
            const startEra = startComponents.era === 1 ? "CE" : "BCE";
            const endEra = endComponents.era === 1 ? "CE" : "BCE";
            
            const startMonthIndex = Math.min(Math.max(startComponents.month - 1, 0), 11);
            const endMonthIndex = Math.min(Math.max(endComponents.month - 1, 0), 11);
            
            const startLabel = `${MONTH_NAMES[startMonthIndex]} ${startComponents.day}, ${formatYear(startComponents.year)} ${pad(startComponents.hour)}:${pad(startComponents.minute)} ${startEra}`;
            const endLabel = `${MONTH_NAMES[endMonthIndex]} ${endComponents.day}, ${formatYear(endComponents.year)} ${pad(endComponents.hour)}:${pad(endComponents.minute)} ${endEra}`;
            
            rangeDisplay.innerHTML = `<strong>${startLabel}</strong> to <strong>${endLabel}</strong>`;
        }

        function rebuildTicks() {
            // Removed - no longer displaying timeline ticks
        }

        function formatSliderLabel(minutes, granularity) {
            if (Math.abs(minutes) < 0.5) {
                return "Center";
            }
            
            const components = minutesToDateComponents(minutes);
            const era = components.era === 1 ? "CE" : "BCE";
            const monthIndex = Math.min(Math.max(components.month - 1, 0), 11);
            
            // Format at the same granularity level as selected
            if (granularity === "Eon") {
                // Show in billions of years for Eon scale
                const eonYears = Math.round(components.year / 1_000_000_000);
                return `${compactFormatter.format(eonYears)} B yrs ${era}`;
            } else if (granularity === "Epoch") {
                // Show in millions of years for Epoch scale
                const epochYears = Math.round(components.year / 1_000_000);
                return `${compactFormatter.format(epochYears)} M yrs ${era}`;
            } else if (granularity === "Age") {
                // Show in thousands of years for Age scale
                const ageYears = Math.round(components.year / 1000);
                return `${compactFormatter.format(ageYears)}K yrs ${era}`;
            } else if (granularity === "Millennium") {
                // Show specific year for Millennium
                return `Year ${compactFormatter.format(components.year)} ${era}`;
            } else if (granularity === "Century") {
                // Show specific year for Century
                return `Year ${compactFormatter.format(components.year)} ${era}`;
            } else if (granularity === "Decade") {
                // Show specific year for Decade
                return `Year ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Year") {
                // Show specific year
                return `Year ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Month") {
                // Show Month and Year
                return `${MONTH_NAMES[monthIndex]} ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Week") {
                // Show Week (calculate from day of year using components)
                // components.month and components.day already account for BCE calendar order
                const dayOfYear = (components.month - 1) * 30 + (components.day - 1);
                const weekNum = Math.floor(dayOfYear / 7) + 1;
                return `Week ${weekNum}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Day") {
                // Show Month, Day, and Year
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Hour") {
                // Show Day and Time with Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${pad(components.hour)}:00 ${era}`;
            } else if (granularity === "Minute") {
                // Show Time with minutes and Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${pad(components.hour)}:${pad(components.minute)} ${era}`;
            }
            
            // Fallback
            return formatYearLabel(minutes);
        }

        function updatePointerAndDetails() {
            // Removed - no longer displaying pointer and details
        }

        function formatYearLabel(minutes) {
            if (minutes === 0) {
                return "Year 1 CE";
            }
            
            const components = minutesToDateComponents(minutes);
            const label = compactFormatter.format(components.year);
            const era = components.era === 1 ? "CE" : "BCE";
            return `Year ${label} ${era}`;
        }

        function formatTickLabel(minutes) {
            if (minutes === 0) {
                return "Center";
            }
            
            // Use the fine granularity for tick labels
            const granularity = getCurrentFineGranularity();
            
            // For large time scales (Eon, Epoch, Age, Millennium, Century, Decade, Year), use year-based format
            if (granularity === "Eon" || granularity === "Epoch" || granularity === "Age" || 
                granularity === "Millennium" || granularity === "Century" || granularity === "Decade" || 
                granularity === "Year") {
                return formatYearLabel(minutes);
            }
            
            // For sub-year granularities, use minutesToDateComponents to get correct date
            const components = minutesToDateComponents(minutes);
            const era = components.era === 1 ? "CE" : "BCE";
            const monthIndex = Math.min(Math.max(components.month - 1, 0), 11);
            
            // Format based on granularity
            if (granularity === "Month") {
                // Show Month and Year
                return `${MONTH_NAMES[monthIndex]} ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Week" || granularity === "Day") {
                // Show Month, Day, and Year
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Hour") {
                // Show Day and Time with Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:00 ${era}`;
            } else {
                // Minute
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:${pad(components.minute)} ${era}`;
            }
        }

        function formatDetailedTime(minutes, granularity) {
            if (minutes === 0) {
                return "Center (Year 1 CE  Month 1  Day 1  00:00)";
            }
            
            const components = minutesToDateComponents(minutes);
            const era = components.era === 1 ? "CE" : "BCE";
            const monthIndex = Math.min(Math.max(components.month - 1, 0), 11);
            
            // Format based on granularity
            if (granularity === "Eon" || granularity === "Epoch" || granularity === "Age" || 
                granularity === "Millennium" || granularity === "Century" || granularity === "Decade") {
                // For very large scales, show year with compact notation
                const yearLabel = compactFormatter.format(components.year);
                return `Year ${yearLabel} ${era}`;
            } else if (granularity === "Year") {
                // Show full year
                return `Year ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Month") {
                // Show Month and Year
                return `${MONTH_NAMES[monthIndex]} ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Week" || granularity === "Day") {
                // Show Month, Day, and Year
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} ${era}`;
            } else if (granularity === "Hour") {
                // Show Day and Time with Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:00 ${era}`;
            } else if (granularity === "Minute") {
                // Show Time with minutes and Era
                return `${MONTH_NAMES[monthIndex]} ${components.day}, ${formatYear(components.year)} at ${pad(components.hour)}:${pad(components.minute)} ${era}`;
            }

            // Fallback to detailed format
            return `Year ${formatYear(components.year)} ${era}  Month ${components.month}  Day ${components.day}  ${pad(components.hour)}:${pad(components.minute)}`;
        }

        function formatDifference(minutes, granularity) {
            if (minutes === 0) {
                return "Exactly at the center moment.";
            }
            const unitMinutes = GRANULARITY_TO_MINUTES[granularity];
            const diffUnits = minutes / unitMinutes;
            const direction = minutes >= 0 ? "after" : "before";
            const absoluteUnits = Math.abs(diffUnits);
            const formattedUnits = absoluteUnits >= 1000
                ? numberFormatter.format(Math.round(absoluteUnits))
                : absoluteUnits.toFixed(2);
            const unitLabel = getUnitLabel(granularity, Math.abs(absoluteUnits - 1) >= 1e-6, false);
            return `${formattedUnits} ${unitLabel} ${direction} the center moment.`;
        }

        function getUnitLabel(granularity, isPlural, capitalize) {
            const entry = UNIT_LABELS[granularity];
            if (!entry) {
                return granularity;
            }
            const text = isPlural ? entry.plural : entry.singular;
            return capitalize ? text.charAt(0).toUpperCase() + text.slice(1) : text;
        }

        function formatYearInputValue(minutes) {
            const years = minutes / MINUTES_PER_YEAR;
            const rounded = Math.round(years * 1000) / 1000;
            const sanitized = Math.abs(rounded) < 1e-6 ? 0 : rounded;
            return sanitized.toString();
        }

        function pad(value) {
            return value.toString().padStart(2, "0");
        }

        // Calculate minimum span in minutes to allow grabbing the range between handles
        function calculateMinPixelSpan(wrapperWidth, totalRange) {
            const minPixels = 50; // Minimum pixel separation to allow grabbing the range bar
            const effectiveWidth = wrapperWidth - 24; // Account for padding
            return (minPixels / effectiveWidth) * totalRange;
        }

        // Get the geologic period and color for a given time position
        function getGeologicColorForPosition(minutes) {
            // Check if position is in the future
            if (minutes > CURRENT_DATE_MINUTES) {
                return 'rgba(168, 85, 247, 0.8)'; // Purple for future
            }
            
            // Find the geologic period that contains this position
            for (let i = 0; i < GEOLOGIC_PERIODS.length; i++) {
                const period = GEOLOGIC_PERIODS[i];
                const periodEnd = (period.endMya === 0) ? CURRENT_DATE_MINUTES : period.endMinutes;
                
                if (minutes >= period.startMinutes && minutes <= periodEnd) {
                    return period.color;
                }
            }
            
            // Default to blue for times before oldest period
            return 'rgba(14, 165, 233, 0.8)';
        }
        
        // Apply color to a handle based on its position
        function applyHandleColor(handle, minutes) {
            const color = getGeologicColorForPosition(minutes);
            handle.style.background = color;
            // Keep the white border
            handle.style.border = '3px solid white';
        }

        // Apply two-tone gradient to track based on current date position
        function applyTwoToneGradient(element, startMinutes, endMinutes, isWrapper = false, isMainTrack = false, selectedRangeIncludesToday = false) {
            const totalRange = endMinutes - startMinutes;
            
            // If current date is outside the range, use single color
            if (CURRENT_DATE_MINUTES <= startMinutes) {
                // Entire range is in the future
                if (isWrapper) {
                    element.style.background = 'linear-gradient(90deg, rgba(168, 85, 247, 0.15), rgba(126, 34, 206, 0.15))';
                } else if (isMainTrack) {
                    element.style.background = 'linear-gradient(90deg, rgba(168, 85, 247, 0.3), rgba(126, 34, 206, 0.6), rgba(168, 85, 247, 0.3))';
                    element.style.boxShadow = 'inset 0 0 12px rgba(168, 85, 247, 0.35)';
                } else {
                    element.style.background = 'rgba(168, 85, 247, 0.3)';
                }
            } else if (CURRENT_DATE_MINUTES >= endMinutes) {
                // Entire range is in the past
                if (isWrapper) {
                    element.style.background = 'linear-gradient(90deg, rgba(14, 165, 233, 0.15), rgba(37, 99, 235, 0.15))';
                } else if (isMainTrack) {
                    element.style.background = 'linear-gradient(90deg, rgba(14, 165, 233, 0.3), rgba(2, 132, 199, 0.6), rgba(14, 165, 233, 0.3))';
                    element.style.boxShadow = 'inset 0 0 12px rgba(14, 165, 233, 0.35)';
                } else {
                    // Regular track - use blue for past
                    element.style.background = 'rgba(14, 165, 233, 0.3)';
                }
            } else {
                // Current date falls within the range - create split gradient
                const currentPercent = ((CURRENT_DATE_MINUTES - startMinutes) / totalRange) * 100;
                
                if (isWrapper) {
                    // Apply padding adjustment only when selected range does NOT include today
                    let adjustedPercent = currentPercent;
                    if (!selectedRangeIncludesToday) {
                        // Wrapper has 12px padding on each side, adjust percentage to align with track area
                        const paddingPx = 12;
                        const wrapperWidth = element.offsetWidth;
                        const paddingPercent = (paddingPx / wrapperWidth) * 100;
                        adjustedPercent = paddingPercent + currentPercent * (1 - 2 * paddingPercent / 100);
                    }
                    
                    element.style.background = `linear-gradient(90deg, 
                        rgba(14, 165, 233, 0.15) 0%, 
                        rgba(37, 99, 235, 0.15) ${adjustedPercent}%, 
                        rgba(168, 85, 247, 0.15) ${adjustedPercent}%, 
                        rgba(126, 34, 206, 0.15) 100%)`;
                } else if (isMainTrack) {
                    element.style.background = `linear-gradient(90deg, 
                        rgba(14, 165, 233, 0.3) 0%,
                        rgba(2, 132, 199, 0.6) ${currentPercent / 2}%,
                        rgba(14, 165, 233, 0.3) ${currentPercent}%,
                        rgba(168, 85, 247, 0.3) ${currentPercent}%,
                        rgba(126, 34, 206, 0.6) ${(100 + currentPercent) / 2}%,
                        rgba(168, 85, 247, 0.3) 100%)`;
                    element.style.boxShadow = 'inset 0 0 12px rgba(14, 165, 233, 0.2), inset 0 0 12px rgba(168, 85, 247, 0.2)';
                } else {
                    // Regular track - use blue for past, purple for future
                    element.style.background = `linear-gradient(90deg, 
                        rgba(14, 165, 233, 0.3) 0%, 
                        rgba(14, 165, 233, 0.3) ${currentPercent}%, 
                        rgba(168, 85, 247, 0.3) ${currentPercent}%, 
                        rgba(168, 85, 247, 0.3) 100%)`;
                }
            }
        }

        // Apply two-tone gradient to selected range bar based on current date position
        function applySelectedRangeGradient(element, rangeStartMinutes, rangeEndMinutes, viewStartMinutes, viewEndMinutes) {
            // If range doesn't span the current date, use simple gradient
            if (CURRENT_DATE_MINUTES <= rangeStartMinutes) {
                // Entire range is in the future
                element.style.background = 'linear-gradient(90deg, var(--future-accent), var(--future-accent-dark))';
            } else if (CURRENT_DATE_MINUTES >= rangeEndMinutes) {
                // Entire range is in the past
                element.style.background = 'linear-gradient(90deg, var(--accent), var(--accent-dark))';
            } else {
                // Range spans the current date
                // Calculate where "today" falls within the selected range itself
                // The selected bar is positioned in track coordinates, so we don't need wrapper padding adjustment
                const selectedRange = rangeEndMinutes - rangeStartMinutes;
                const currentPercentInSelected = ((CURRENT_DATE_MINUTES - rangeStartMinutes) / selectedRange) * 100;
                
                // Apply gradient using the selected range percentage
                // This ensures the transition aligns with where "today" actually falls in the bar
                element.style.background = `linear-gradient(90deg, 
                    var(--accent) 0%, 
                    var(--accent-dark) ${currentPercentInSelected}%, 
                    var(--future-accent) ${currentPercentInSelected}%, 
                    var(--future-accent-dark) 100%)`;
            }
        }

        // Range slider functionality
        function updateRangeSliders() {
            updateBottomSlider();
            updateTopSlider();
        }

        function updateBottomSlider() {
            // Bottom slider boundaries are set by the date inputs (viewStartMinutes and viewEndMinutes)
            const totalRange = viewEndMinutes - viewStartMinutes;
            
            // Prevent division by zero
            if (totalRange === 0) {
                bottomStartHandle.style.left = '50%';
                bottomEndHandle.style.left = '50%';
                bottomSelected.style.left = '50%';
                bottomSelected.style.width = '0%';
                return;
            }
            
            const startPercent = ((bottomStartMinutes - viewStartMinutes) / totalRange) * 100;
            const endPercent = ((bottomEndMinutes - viewStartMinutes) / totalRange) * 100;
            
            bottomStartHandle.style.left = `${startPercent}%`;
            bottomEndHandle.style.left = `${endPercent}%`;
            bottomSelected.style.left = `${startPercent}%`;
            bottomSelected.style.width = `${endPercent - startPercent}%`;
            
            // Apply gradient to selected range based on whether it spans the current date
            applySelectedRangeGradient(bottomSelected, bottomStartMinutes, bottomEndMinutes, viewStartMinutes, viewEndMinutes);
            
            // Apply colors to handles based on their position in the timeline
            applyHandleColor(bottomStartHandle, bottomStartMinutes);
            applyHandleColor(bottomEndHandle, bottomEndMinutes);
            
            // Apply two-tone gradient to wrapper only (track gradient is provided by geologic segments)
            // Pass whether the selected range (bottom range) includes today
            const bottomRangeIncludesToday = (CURRENT_DATE_MINUTES >= bottomStartMinutes && CURRENT_DATE_MINUTES <= bottomEndMinutes);
            applyTwoToneGradient(bottomSliderWrapper, viewStartMinutes, viewEndMinutes, true, false, bottomRangeIncludesToday);
            
            // Render geologic segments
            renderGeologicSegments(bottomGeologicSegments, viewStartMinutes, viewEndMinutes);
        }

        function updateTopSlider() {
            const totalRange = bottomEndMinutes - bottomStartMinutes;
            
            // Prevent division by zero
            if (totalRange === 0) {
                topStartHandle.style.left = '50%';
                topEndHandle.style.left = '50%';
                topSelected.style.left = '50%';
                topSelected.style.width = '0%';
                return;
            }
            
            const startPercent = ((topStartMinutes - bottomStartMinutes) / totalRange) * 100;
            const endPercent = ((topEndMinutes - bottomStartMinutes) / totalRange) * 100;
            
            topStartHandle.style.left = `${startPercent}%`;
            topEndHandle.style.left = `${endPercent}%`;
            topSelected.style.left = `${startPercent}%`;
            topSelected.style.width = `${endPercent - startPercent}%`;
            
            // Apply gradient to selected range based on whether it spans the current date
            applySelectedRangeGradient(topSelected, topStartMinutes, topEndMinutes, bottomStartMinutes, bottomEndMinutes);
            
            // Apply colors to handles based on their position in the timeline
            applyHandleColor(topStartHandle, topStartMinutes);
            applyHandleColor(topEndHandle, topEndMinutes);
            
            // Apply two-tone gradient to wrapper only (track gradient is provided by geologic segments)
            // Pass whether the selected range (top range) includes today
            const topRangeIncludesToday = (CURRENT_DATE_MINUTES >= topStartMinutes && CURRENT_DATE_MINUTES <= topEndMinutes);
            applyTwoToneGradient(topSliderWrapper, bottomStartMinutes, bottomEndMinutes, true, false, topRangeIncludesToday);
            
            // Render geologic segments
            renderGeologicSegments(topGeologicSegments, bottomStartMinutes, bottomEndMinutes);
        }

        // Drag handling for bottom timeline
        let dragState = null;

        function startBottomDrag(type, event) {
            event.preventDefault();
            const rect = bottomSliderWrapper.getBoundingClientRect();
            // Bottom slider boundaries are set by the date inputs
            const totalRange = viewEndMinutes - viewStartMinutes;
            
            dragState = {
                type: type,
                timeline: 'bottom',
                startX: event.clientX,
                startMinutesStart: bottomStartMinutes,
                startMinutesEnd: bottomEndMinutes,
                wrapperRect: rect,
                totalRange: totalRange,
                boundaryMin: viewStartMinutes,
                boundaryMax: viewEndMinutes
            };
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', endDrag);
        }

        function startTopDrag(type, event) {
            event.preventDefault();
            const rect = topSliderWrapper.getBoundingClientRect();
            const totalRange = bottomEndMinutes - bottomStartMinutes;
            
            dragState = {
                type: type,
                timeline: 'top',
                startX: event.clientX,
                startMinutesStart: topStartMinutes,
                startMinutesEnd: topEndMinutes,
                wrapperRect: rect,
                totalRange: totalRange
            };
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', endDrag);
        }

        function handleDrag(event) {
            if (!dragState) return;
            
            const deltaX = event.clientX - dragState.startX;
            const wrapperWidth = dragState.wrapperRect.width - 24; // Account for padding
            const deltaPercent = deltaX / wrapperWidth;
            const deltaMinutes = deltaPercent * dragState.totalRange;
            
            if (dragState.timeline === 'bottom') {
                handleBottomDrag(deltaMinutes);
            } else {
                handleTopDrag(deltaMinutes);
            }
        }

        function handleBottomDrag(deltaMinutes) {
            const boundaryMin = dragState.boundaryMin || viewStartMinutes;
            const boundaryMax = dragState.boundaryMax || viewEndMinutes;
            
            // Calculate minimum span based on 50px minimum separation to allow grabbing the range bar
            const minPixelSpan = calculateMinPixelSpan(dragState.wrapperRect.width, dragState.totalRange);
            
            // Use only the pixel-based minimum (no hardcoded time-based minimum)
            const effectiveMinSpan = minPixelSpan;
            
            if (dragState.type === 'start') {
                let newStart = dragState.startMinutesStart + deltaMinutes;
                // Constrain within date input boundaries
                newStart = Math.max(boundaryMin, Math.min(newStart, bottomEndMinutes - effectiveMinSpan));
                newStart = Math.max(boundaryMin, newStart); // Ensure it doesn't go below min
                bottomStartMinutes = newStart;
                
                // If start moved, ensure end respects boundaries too
                if (bottomEndMinutes > boundaryMax) {
                    bottomEndMinutes = boundaryMax;
                }
                if (bottomEndMinutes - bottomStartMinutes < effectiveMinSpan) {
                    bottomEndMinutes = Math.min(boundaryMax, bottomStartMinutes + effectiveMinSpan);
                }
                
                // Constrain top timeline within new bottom bounds
                const bottomSpan = bottomEndMinutes - bottomStartMinutes;
                const fineGranularity = getCurrentFineGranularity();
                const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
                topStartMinutes = Math.max(bottomStartMinutes, Math.min(topStartMinutes, bottomEndMinutes - minTopSpan));
                topEndMinutes = Math.min(bottomEndMinutes, Math.max(topEndMinutes, topStartMinutes + minTopSpan));
            } else if (dragState.type === 'end') {
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                // Constrain within date input boundaries
                newEnd = Math.min(boundaryMax, Math.max(newEnd, bottomStartMinutes + effectiveMinSpan));
                newEnd = Math.min(boundaryMax, newEnd); // Ensure it doesn't go above max
                bottomEndMinutes = newEnd;
                
                // If end moved, ensure start respects boundaries too
                if (bottomStartMinutes < boundaryMin) {
                    bottomStartMinutes = boundaryMin;
                }
                if (bottomEndMinutes - bottomStartMinutes < effectiveMinSpan) {
                    bottomStartMinutes = Math.max(boundaryMin, bottomEndMinutes - effectiveMinSpan);
                }
                
                // Constrain top timeline within new bottom bounds
                const bottomSpan = bottomEndMinutes - bottomStartMinutes;
                const fineGranularity = getCurrentFineGranularity();
                const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
                topStartMinutes = Math.max(bottomStartMinutes, Math.min(topStartMinutes, bottomEndMinutes - minTopSpan));
                topEndMinutes = Math.min(bottomEndMinutes, Math.max(topEndMinutes, topStartMinutes + minTopSpan));
            } else if (dragState.type === 'range') {
                const span = dragState.startMinutesEnd - dragState.startMinutesStart;
                
                // Prevent division by zero
                if (span === 0) {
                    return;
                }
                
                let newStart = dragState.startMinutesStart + deltaMinutes;
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                
                // Keep within date input boundaries
                if (newStart < boundaryMin) {
                    newStart = boundaryMin;
                    newEnd = newStart + span;
                }
                if (newEnd > boundaryMax) {
                    newEnd = boundaryMax;
                    newStart = newEnd - span;
                }
                
                // Double-check both are within bounds
                newStart = Math.max(boundaryMin, Math.min(newStart, boundaryMax - span));
                newEnd = Math.min(boundaryMax, Math.max(newEnd, boundaryMin + span));
                
                bottomStartMinutes = newStart;
                bottomEndMinutes = newEnd;
                
                // Move top timeline proportionally
                const topSpan = topEndMinutes - topStartMinutes;
                const dragSpan = dragState.startMinutesEnd - dragState.startMinutesStart;
                
                // This check should never fail since we already checked above, but adding for safety
                if (dragSpan !== 0) {
                    const topRelativeStart = (topStartMinutes - dragState.startMinutesStart) / dragSpan;
                    topStartMinutes = bottomStartMinutes + topRelativeStart * (bottomEndMinutes - bottomStartMinutes);
                    topEndMinutes = topStartMinutes + topSpan;
                }
                
                // Ensure top stays within bottom bounds
                topStartMinutes = Math.max(bottomStartMinutes, Math.min(topStartMinutes, bottomEndMinutes - topSpan));
                topEndMinutes = topStartMinutes + topSpan;
            }
            
            updateRangeSliders();
            // Update the main view display to show the top timeline's range
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        function handleTopDrag(deltaMinutes) {
            const fineGranularity = getCurrentFineGranularity();
            const minTopSpan = GRANULARITY_TO_MINUTES[fineGranularity];
            
            // Calculate minimum span based on 20px minimum separation
            const minPixelSpan = calculateMinPixelSpan(dragState.wrapperRect.width, dragState.totalRange);
            
            // Use the larger of the time-based minimum or the pixel-based minimum
            const effectiveMinSpan = Math.max(minTopSpan, minPixelSpan);
            
            if (dragState.type === 'start') {
                let newStart = dragState.startMinutesStart + deltaMinutes;
                newStart = Math.max(bottomStartMinutes, newStart);
                newStart = Math.min(newStart, topEndMinutes - effectiveMinSpan);
                topStartMinutes = newStart;
            } else if (dragState.type === 'end') {
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                newEnd = Math.min(bottomEndMinutes, newEnd);
                newEnd = Math.max(newEnd, topStartMinutes + effectiveMinSpan);
                topEndMinutes = newEnd;
            } else if (dragState.type === 'range') {
                const span = dragState.startMinutesEnd - dragState.startMinutesStart;
                let newStart = dragState.startMinutesStart + deltaMinutes;
                let newEnd = dragState.startMinutesEnd + deltaMinutes;
                
                // Keep within bottom timeline bounds
                if (newStart < bottomStartMinutes) {
                    newStart = bottomStartMinutes;
                    newEnd = newStart + span;
                }
                if (newEnd > bottomEndMinutes) {
                    newEnd = bottomEndMinutes;
                    newStart = newEnd - span;
                }
                
                topStartMinutes = newStart;
                topEndMinutes = newEnd;
            }
            
            updateRangeSliders();
            // Update the main view display to show the top timeline's range
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        function endDrag() {
            dragState = null;
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', endDrag);
        }

        function updateViewFromTopTimeline() {
            viewStartMinutes = topStartMinutes;
            viewEndMinutes = topEndMinutes;
            currentViewMinutes = (topStartMinutes + topEndMinutes) / 2;
            
            refreshRangeDisplay();
            rebuildTicks();
            updatePointerAndDetails();
        }

        // Event listeners for bottom timeline
        bottomStartHandle.addEventListener('mousedown', (e) => startBottomDrag('start', e));
        bottomEndHandle.addEventListener('mousedown', (e) => startBottomDrag('end', e));
        bottomSelected.addEventListener('mousedown', (e) => startBottomDrag('range', e));

        // Event listeners for top timeline
        topStartHandle.addEventListener('mousedown', (e) => startTopDrag('start', e));
        topEndHandle.addEventListener('mousedown', (e) => startTopDrag('end', e));
        topSelected.addEventListener('mousedown', (e) => startTopDrag('range', e));

        // Vertical slider event handlers
        
        // Granularity slider drag handling
        let granularityDragState = null;
        
        function startGranularityDrag(isStart, event) {
            event.preventDefault();
            const slider = isStart ? startGranularitySlider : endGranularitySlider;
            const rect = slider.getBoundingClientRect();
            
            granularityDragState = {
                isStart: isStart,
                rect: rect
            };
            
            document.addEventListener('mousemove', handleGranularityDrag);
            document.addEventListener('mouseup', endGranularityDrag);
            
            // Immediately update position
            handleGranularityDrag(event);
        }
        
        function handleGranularityDrag(event) {
            if (!granularityDragState) return;
            
            const rect = granularityDragState.rect;
            const y = event.clientY - rect.top;
            const percent = Math.max(0, Math.min(1, y / rect.height));
            
            // Top = finest (0), Bottom = coarsest (length-1)
            const index = Math.round((1 - percent) * (GRANULARITY_LEVELS.length - 1));
            
            if (granularityDragState.isStart) {
                startGranularityIndex = index;
            } else {
                endGranularityIndex = index;
            }
            
            updateGranularitySliders();
        }
        
        function endGranularityDrag() {
            granularityDragState = null;
            document.removeEventListener('mousemove', handleGranularityDrag);
            document.removeEventListener('mouseup', endGranularityDrag);
        }
        
        // Date adjustment slider handling
        let dateAdjustmentDragState = null;
        
        function startDateAdjustmentDrag(isStart, event) {
            event.preventDefault();
            const slider = isStart ? startDateSlider : endDateSlider;
            const rect = slider.getBoundingClientRect();
            
            dateAdjustmentDragState = {
                isStart: isStart,
                rect: rect
            };
            
            document.addEventListener('mousemove', handleDateAdjustmentDrag);
            document.addEventListener('mouseup', endDateAdjustmentDrag);
            
            // Start animation
            if (isStart) {
                if (startDateAdjustmentInterval) clearInterval(startDateAdjustmentInterval);
                startDateAdjustmentInterval = setInterval(() => updateDateFromSlider(true), 50);
            } else {
                if (endDateAdjustmentInterval) clearInterval(endDateAdjustmentInterval);
                endDateAdjustmentInterval = setInterval(() => updateDateFromSlider(false), 50);
            }
        }
        
        function handleDateAdjustmentDrag(event) {
            if (!dateAdjustmentDragState) return;
            
            const rect = dateAdjustmentDragState.rect;
            const y = event.clientY - rect.top;
            const percent = Math.max(0, Math.min(1, y / rect.height));
            
            const handle = dateAdjustmentDragState.isStart ? startDateHandle : endDateHandle;
            handle.style.top = `${percent * 100}%`;
        }
        
        function endDateAdjustmentDrag() {
            if (!dateAdjustmentDragState) return;
            
            const isStart = dateAdjustmentDragState.isStart;
            dateAdjustmentDragState = null;
            
            document.removeEventListener('mousemove', handleDateAdjustmentDrag);
            document.removeEventListener('mouseup', endDateAdjustmentDrag);
            
            // Stop animation and reset slider to center
            if (isStart) {
                if (startDateAdjustmentInterval) {
                    clearInterval(startDateAdjustmentInterval);
                    startDateAdjustmentInterval = null;
                }
                startDateHandle.style.top = '50%';
            } else {
                if (endDateAdjustmentInterval) {
                    clearInterval(endDateAdjustmentInterval);
                    endDateAdjustmentInterval = null;
                }
                endDateHandle.style.top = '50%';
            }
        }
        
        function updateDateFromSlider(isStart) {
            const handle = isStart ? startDateHandle : endDateHandle;
            const topPercent = parseFloat(handle.style.top) / 100;
            
            // Center is at 50%, calculate offset from center
            const offset = 0.5 - topPercent; // Positive = moving forward, negative = moving backward
            
            // Calculate rate based on distance from center (exponential)
            // At center: 0, At edges: max speed
            const absOffset = Math.abs(offset);
            const rate = Math.pow(absOffset * 2, 2); // Quadratic scaling for smooth acceleration
            
            if (Math.abs(rate) < 0.01) return; // Dead zone at center
            
            // Get granularity
            const granularityIndex = isStart ? startGranularityIndex : endGranularityIndex;
            const granularity = GRANULARITY_LEVELS[granularityIndex];
            const minutesPerUnit = GRANULARITY_TO_MINUTES[granularity];
            
            // Calculate change in minutes (rate determines speed)
            // Use speedMultiplier to control animation speed (0.01 to 1.0)
            const direction = offset > 0 ? 1 : -1;
            const deltaMinutes = direction * rate * minutesPerUnit * 0.1 * speedMultiplier; // Scale factor for reasonable speed, multiplied by speed slider value
            
            // Vertical sliders adjust the coarse track boundaries (viewStartMinutes/viewEndMinutes)
            if (isStart) {
                viewStartMinutes = clampMinutes(viewStartMinutes + deltaMinutes);
                // Ensure minimum span
                if (viewEndMinutes - viewStartMinutes < minutesPerUnit) {
                    viewStartMinutes = viewEndMinutes - minutesPerUnit;
                }
            } else {
                viewEndMinutes = clampMinutes(viewEndMinutes + deltaMinutes);
                // Ensure minimum span
                if (viewEndMinutes - viewStartMinutes < minutesPerUnit) {
                    viewEndMinutes = viewStartMinutes + minutesPerUnit;
                }
            }
            
            // Keep bottom handles within new view boundaries
            bottomStartMinutes = Math.max(viewStartMinutes, Math.min(bottomStartMinutes, viewEndMinutes));
            bottomEndMinutes = Math.max(viewStartMinutes, Math.min(bottomEndMinutes, viewEndMinutes));
            
            // Update top slider to stay within bottom handle bounds
            topStartMinutes = Math.max(bottomStartMinutes, Math.min(topStartMinutes, bottomEndMinutes));
            topEndMinutes = Math.max(bottomStartMinutes, Math.min(topEndMinutes, bottomEndMinutes));
            
            updateRangeSliders();
            updateDateDisplays();
            refreshRangeDisplay();
        }
        
        // Add event listeners for vertical sliders
        startGranularitySlider.addEventListener('mousedown', (e) => startGranularityDrag(true, e));
        endGranularitySlider.addEventListener('mousedown', (e) => startGranularityDrag(false, e));
        
        startDateSlider.addEventListener('mousedown', (e) => startDateAdjustmentDrag(true, e));
        endDateSlider.addEventListener('mousedown', (e) => startDateAdjustmentDrag(false, e));

        // Speed slider event listener
        speedSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            // Convert 1-100 to 0.02-2.0, where 50 = 1.0 (current speed), 100 = 2.0 (4x faster than old 50%)
            speedMultiplier = value / 50;
        });

        // Initialize
        initializeTimelines();
        updateGranularitySliders();
        resetDateSliders();
        updateDateDisplays();
        updateRangeSliders();
        refreshRangeDisplay();
        rebuildTicks();
        updatePointerAndDetails();
    </script>
</body>
</html>
